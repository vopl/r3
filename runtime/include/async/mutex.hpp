#ifndef _ASYNC_MUTEX_HPP_
#define _ASYNC_MUTEX_HPP_

#include "async/api.h"
#include <boost/shared_ptr.hpp>


//////////////////////////////////////////////////////////////////////////
namespace async
{
	class MutexImpl;
	typedef boost::shared_ptr<MutexImpl> MutexImplPtr;

	//////////////////////////////////////////////////////////////////////////
	/*!	\ingroup async
		\brief Примитив синхронизации - мутекс

		В отличии от других мутексов(boost, pthread) предназначен для защиты \e "самого ресурса" а не 
		\e "потока/фибера, который использует какаой то ресурс", тоесть более похож на семафор с порогом 1

		По отношению к какому либо фиберу - мутекс может находится в одном из состояний
			- не захвачен (то есть, как бы и отношения не имеет вообще)
			- захвачен
			- ожидает захвата
	*/
	class ASYNC_API Mutex
	{
		MutexImplPtr	_impl;

	public:
		/*!	\brief Конструирование
			
			После создания объект находится в не-заблокированном состоянии
		*/
		Mutex();

		/*!	\brief Попытка захвата, без ожидания
			
			Предпринимает попытку мягкого захвата. 
			Если на момент вызова мутекс никем не захвачен - то он захватывается этим методом.
			Если на момент вызова мутекс уже был захвачен - то ничего не происходит.

			\retval true если мутекс захвачен (мутекс ранее был свободен и сейчас захвачен этим вызовом)
			\retval false если мутекс не захвачен (мутекс уже захвачен кем то еще)
		*/
		bool tryLock();

		/*!	\brief Захват с ожиданием
			
			Если ранее мутекс не был захвачен - то он захватывается
			
			Если мутекс уже захвачен - то текущий фибер складируется в очередь "ожидающих захвата", когда подойдет очередь - фибер будет активирован и выполнение метода завершится.

			\post мутекс захвачен
		*/
		void lock();

		/*!	\brief Проверка на захват

			\retval true если если мутекс захвачен
			\retval false если если мутекс не захвачен
		*/
		bool isLocked();

		/*!	\brief Освобождение

			\pre ранее мутекс был захвачен

			Если ранее не был произведен захват - это нештатная ситуация, будет выброшено исключение async::exception

			Если ранее был произведен захват - он анулируется и активируется очередной фибер из очереди "ожидающих захвата"
		*/
		void unlock();

	public:
		/*!	\brief RAII обертка

			пример использования
			\code
				void myFunction(...)
				{
					if(needWorkWithSharedResource)
					{
						//нужно поработать с общим ресурсом sharedResource, доступ к которому синхронизируется мутексом sharedResourceMutex

						//захват
						async::Mutex::ScopedLock sl(sharedResourceMutex);

						sharedResource.work1();
						...
						if(some)
						{
							//освобождение автоматически, заботится не нужно
							return;
						}
						...
						if(some)
						{
							//освобождение автоматически, заботится не нужно
							throw 220;
						}
						...
						sharedResource.workN();

						//освобождение автоматически, заботится не нужно
					}
				}
			\endcode
		*/
		struct ScopedLock
		{
		public:
			/*!	\brief Конструирование новой обертки
				
				\param mutex - управляемый мутекс, будет сохранен по ссылке

				Производит захват

				\post мутекс захвачен
			*/
			ScopedLock(Mutex &mutex)
				: _mutex(mutex)
			{
				_mutex.lock();
			}

			/*!	\brief Разрушение обертки
				
				Производит освобождение захваченного в конструкторе мутекса

				\post мутекс освобожден
			*/
			~ScopedLock()
			{
				_mutex.unlock();
			}

		private:
			Mutex &_mutex;
		};

	};
}

#endif
