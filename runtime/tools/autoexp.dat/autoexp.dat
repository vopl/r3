; AutoExp.Dat - templates for automatically expanding data
; Copyright(c) Microsoft Corporation. All Rights Reserved.
;---------------------------------------------------------------
;
; While debugging, Data Tips and items in the Watch and Variable
; windows are automatically expanded to show their most important
; elements. The expansion follows the format given by the rules
; in this file. You can add rules for your types or change the
; predefined rules.
;
; For good examples, read the rules in this file.
;
; To find what the debugger considers the type of a variable to
; be, add it to the Watch window and look at the Type column.
;
; An AutoExpand rule is a line with the name of a type, an equals
; sign, and text with replaceable parts in angle brackets. The
; part in angle brackets names a member of the type and an
; optional Watch format specifier.
;
; AutoExpand rules use the following syntax. The equals sign (=),
; angle brackets (<>), and comma are taken literally. Square
; brackets ([]) indicate optional items.
;
; type=[text]<member[,format]>...
;
; type		Name of the type (may be followed by <*> for template
;			types such as the ATL types listed below).
;
; text		Any text.Usually the name of the member to display,
;			or a shorthand name for the member.
;
; member	Name of a member to display.
;
; format	Watch format specifier. One of the following:
;
;	Letter	Description					Sample		   Display
;	------	--------------------------	------------   -------------
;	d,i		Signed decimal integer		0xF000F065,d   -268373915
;	u		Unsigned decimal integer	0x0065,u	   101
;	o		Unsigned octal integer		0xF065,o	   0170145
;	x,X		Hexadecimal integer			61541,X		   0X0000F065
;	l,h		long or short prefix for	00406042,hx    0x0c22
;			  d, i, u, o, x, X
;	f		Signed floating-point		3./2.,f		   1.500000
;	e		Signed scientific-notation	3./2.,e		   1.500000e+000
;	g		Shorter of e and f			3./2.,g		   1.5
;	c		Single character			0x0065,c	   'e'
;	s		Zero-terminated string		pVar,s		   "Hello world"
;	su		Unicode string				pVar,su		   "Hello world"
;
; For details of other format specifiers see Help under:
; "format specifiers/watch variable"
;
; The special format <,t> specifies the name of the most-derived
; type of the object. This is especially useful with pointers or
; references to a base class.
;
; If there is no rule for a class, the base classes are checked for
; a matching rule.
;
; There are some special entries allowed in the AutoExpand section:
; $BUILTIN is used to display more complex types that need to do more
; than just show a member variable or two.
; $ADDIN allows external DLLs to be added to display even more complex
; types via the EE Add-in API. The first argument is the DLL name, the
; second argument is the name of the export from the DLL to use. For
; further information on this API see the sample called EEAddIn.
;
; WARNING: if hexadecimal mode is on in the watch window, all numbers here are
; evaluated in hex, e.g. 42 becomes 0x42

[AutoExpand]
;QT_DEBUG_START (Qt Visual Studio Add-in v1.1.9)

QByteArray=<d->data,s> size=<d->size,u>
QPoint =x=<xp> y=<yp>
QPointF =x=<xp> y=<yp>
QRect =x1=<x1> y1=<y1> x2=<x2> y2=<y2>
QRectF =x=<xp> y=<yp> w=<w> h=<h>
QSize =width=<wd> height=<ht>
QSizeF =width=<wd> height=<ht>
QHash<*> =size=<d->size>
QVarLengthArray<*> =size=<s> data=<ptr>

;QT_DEBUG_END












































; from windef.h
tagPOINT =x=<x> y=<y>
tagRECT =top=<top> bottom=<bottom> left=<left> right=<right>

; from winuser.h
tagMSG =msg=<message,x> wp=<wParam,x> lp=<lParam,x>

; intrinsics
__m64 =<m64_i64,x>
__m128=$BUILTIN(M128)
__m128i=$BUILTIN(M128I)
__m128d=$BUILTIN(M128D)

; from afxwin.h
CDC =hDC=<m_hDC> attrib=<m_hAttribDC>
CPaintDC =<,t> hWnd=<m_hWnd>
CPoint =x=<x> y=<y>
CRect =top=<top> bottom=<bottom> left=<left> right=<right>
CSize =cx=<cx> cy=<cy>
CWnd =<,t> hWnd=<m_hWnd>
CWinApp =<,t> <m_pszAppName,s>
CWinThread =<,t> h=<m_hThread> proc=<m_pfnThreadProc>

; from afxcoll.h
CPtrList =cnt=<m_nCount>

; from afxstat_.h
CProcessLocalObject =<,t>
CThreadLocalObject =<,t>

; from afx.h
CArchiveException =cause=<m_cause>
CFile =hFile=<m_hFile> name=<m_strFileName.m_pchData,s>
CFileException =cause=<m_cause> OS Error=m_lOsError
CMemFile =pos=<m_nPosition> size=<m_nFileSize>
CObject =<,t>
CRuntimeClass =<m_lpszClassName,s>
CStdioFile =FILE*=<m_pStream> name=<m_strFilename.m_pchData,s>
CTimeSpan =time=<m_time>
CTime =time=<m_time>

; from afxcoll.h
CByteArray =count=<m_nCount>
CStringList =count=<m_nCount>
; same for all CXXXArray classes
; same for CXXXList
; same for CMapXXToXX

; various string classes from MFC & ATL

_com_error=<m_hresult,hr>
_bstr_t=<m_Data->m_wstr,su> (<m_Data->m_RefCount,u>)
_com_ptr_t<*>=<m_pInterface>
_LARGE_INTEGER=<QuadPart>
_ULARGE_INTEGER=<QuadPart>
ATL::CComPtr<*>=<p>

ATL::CComQIPtr<*>=<p>

tagVARIANT=$BUILTIN(VARIANT)
VARIANT=$BUILTIN(VARIANT)
_GUID=$BUILTIN(GUID)

; see EEAddIn sample for how to use these
;_SYSTEMTIME=$ADDIN(EEAddIn.dll,AddIn_SystemTime)
;_FILETIME=$ADDIN(EEAddIn.dll,AddIn_FileTime)

std::binder1st<*>= op=<op> value=<value>
std::binder2nd<*>= op=<op> value=<value>
std::less<*>=lessthan
std::greater<*>=greaterthan

[Visualizer]


















;----------------------------------------
; BOOST_VISUALIZER_START boost::date_time
;
; Copyright Bruno Durin 2010. Use, modification and distribution are subject
; to the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt
; or copy at http://www.boost.org/LICENSE_1_0.txt)
;
; @guid     2421DB60-44CC-11DF-9879-0800200C9A66
; @platform msvc-8, msvc-9
; @version  1.0
; @author   Bruno Durin
; @email    bruno dot durin at gmail dot com
;
; Usage
; =====
;
; Unlike the other visualizer for date_time, this visualizer does not need a header
; file to work. Note that the displayed time is in UTC.
;

;------------------------------------------------------------------------------
;  boost::gregorian::date visualizer
;------------------------------------------------------------------------------

boost::gregorian::date{
	preview
	( 
		#( 
			100*((4*($e.days_+32044)+3)/146097)+((4*($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4))+3)/1461)-4800+(((5*($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4)-(1461*((4*($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4))+3)/1461))/4)+2)/153)/10),
			"-",
			((5*($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4)-(1461*((4*($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4))+3)/1461))/4)+2)/153)+3-12*(((5*($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4)-(1461*((4*($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4))+3)/1461))/4)+2)/153)/10),
			"-",
			($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4)-(1461*((4*($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4))+3)/1461))/4)-((153*((5*($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4)-(1461*((4*($e.days_+32044-((146097*((4*($e.days_+32044)+3)/146097))/4))+3)/1461))/4)+2)/153)+2)/5)+1
		 )
	)		
}

;------------------------------------------------------------------------------
;  boost::gregorian::date_duration visualizer
;------------------------------------------------------------------------------

boost::gregorian::date_duration{
	preview
	( 
		#( 
			$c.days_.value_,
			" days"
		 )
	)		
}

;------------------------------------------------------------------------------
;  boost::posix_time::time_duration visualizer
;  only works with microseconds resolution
;------------------------------------------------------------------------------

boost::posix_time::time_duration{
	preview
	( 
		#( 
			$e.ticks_.value_/86400000000,
			"d ",
			($e.ticks_.value_-86400000000*($e.ticks_.value_/86400000000))/3600000000,
			"h ",
			($e.ticks_.value_-86400000000*($e.ticks_.value_/86400000000)-3600000000*(($e.ticks_.value_-86400000000*($e.ticks_.value_/86400000000))/3600000000))/60000000,
			"m ",
			(($e.ticks_.value_-86400000000*($e.ticks_.value_/86400000000)-3600000000*(($e.ticks_.value_-86400000000*($e.ticks_.value_/86400000000))/3600000000))-60000000*(($e.ticks_.value_-86400000000*($e.ticks_.value_/86400000000) - 3600000000*(($e.ticks_.value_-86400000000*($e.ticks_.value_/86400000000))/3600000000))/60000000))/1000000,
			"s ",
			($e.ticks_.value_%1000000)/1000,
			"ms ",
			$e.ticks_.value_%1000,
			"us"
		 )
	)		
}

;------------------------------------------------------------------------------
;  boost::posix_time::ptime visualizer
;  only works with microseconds resolution
;------------------------------------------------------------------------------

boost::posix_time::ptime{
	preview
	( 
		#( 
			100*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097)+((4*(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4))+3)/1461)-4800+(((5*(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4)-(1461*((4*(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4))+3)/1461))/4)+2)/153)/10),
			"-",
			((5*(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4)-(1461*((4*(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4))+3)/1461))/4)+2)/153)+3-12*(((5*(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4)-(1461*((4*(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4))+3)/1461))/4)+2)/153)/10),
			"-",
			(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4)-(1461*((4*(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4))+3)/1461))/4)-((153*((5*(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4)-(1461*((4*(($e.time_.time_count_.value_/86400000000)+32044-((146097*((4*(($e.time_.time_count_.value_/86400000000)+32044)+3)/146097))/4))+3)/1461))/4)+2)/153)+2)/5)+1,
			"  ",
			($e.time_.time_count_.value_-86400000000*($e.time_.time_count_.value_/86400000000))/3600000000,
			"h",
			($e.time_.time_count_.value_-86400000000*($e.time_.time_count_.value_/86400000000)-3600000000*(($e.time_.time_count_.value_-86400000000*($e.time_.time_count_.value_/86400000000))/3600000000))/60000000,
			"m",
			(($e.time_.time_count_.value_-86400000000*($e.time_.time_count_.value_/86400000000)-3600000000*(($e.time_.time_count_.value_-86400000000*($e.time_.time_count_.value_/86400000000))/3600000000))-60000000*(($e.time_.time_count_.value_-86400000000*($e.time_.time_count_.value_/86400000000) - 3600000000*(($e.time_.time_count_.value_-86400000000*($e.time_.time_count_.value_/86400000000))/3600000000))/60000000))/1000000,
			"s (",
			$e.time_.time_count_.value_%1000000,
			"us)"
		 )
	)		
}

;
; BOOST_VISUALIZER_END boost::date_time
;--------------------------------------

;-------------------------------------------
; BOOST_VISUALIZER_START boost::interprocess
;
; Copyright Filip Konvi?ka 2008. Use, modification and distribution are subject to
; the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt
; or copy at http://www.boost.org/LICENSE_1_0.txt)
;
; @guid     bed732a0-daf1-11dc-95ff-0800200c9a66
; @platform msvc-8, msvc-9
; @version  1.0
; @author   Filip Konvi?ka
; @email    filip dot konvicka at logis dot cz
;
; Usage
; =====
;
; Just append this to autoexp.dat.
; Currently this just handles offset_ptr.
;
;
;------------------------------------
; boost::interprocess::offset_ptr
boost::interprocess::offset_ptr<*> {
  preview( #if($e.m_offset==1) (#("null")) #else (#("non-null")) )
  children(
    #(
      #array(
        expr: (($T1*)(((char*)(void*)&$c)+$c.m_offset)),
        size: #if($c.m_offset==1) (0) #else (1)
      ) : $e
    )
  )
}
;
; BOOST_VISUALIZER_END boost::interprocess
;-----------------------------------------


;----------------------------------------------------
; BOOST_VISUALIZER_START boost::multi_index_container
;
; Copyright Filip Konvi?ka 2007 - 2009. Use, modification and distribution are subject
; to the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt
; or copy at http://www.boost.org/LICENSE_1_0.txt)
;
; @guid     CA3A7EDA-43F3-11DC-9D06-4B5856D89593
; @platform msvc-8, msvc-9
; @version  1.1
; @header   mic_visualizer.hpp
; @author   Filip Konvi?ka
; @email    filip dot konvicka at logis dot cz
;
; Usage
; =====
;
; NOTE: This version is known to work with Boost MultiIndex v. 1.34.1. For newer versions, use the other file.
;
; Visualization must be explicitly enabled in the code for each type.
; For each multi_index_container type, you need to call
;
;   VISUALIZE_MULTI_INDEX_CONTAINER(TypeName);
;
; at global namespace level. The macro is defined in the accompanying header file mic_visualizer.hpp.
;
;
;------------------------------------
; boost::multi_index_container - base
;
; This passes control to the header_holder decoders :-)
boost::multi_index::multi_index_container<*,*,*>{
  preview(#($c.node_count, " items (multi_index_container)"))
  children(
    #(
      data:((msvc_helpers::multi_index_helper_2<boost::multi_index::multi_index_container<$T1,$T2,$T3> >*)&$c)->header,
      original members: [$c,!]
    )
  )
}
;-----------------------------------------------
; boost::multi_index_container - sequenced index
boost::multi_index::detail::header_holder<boost::multi_index::detail::sequenced_index_node<*>,*>{
  preview(#("sequenced index"))
  children(
    #(
      #list(
            head : *(((boost::multi_index::detail::sequenced_index_node_impl*)(boost::multi_index::detail::sequenced_index_node_trampoline<$T1>*)($c.member))->next_),
            size : (($T2*)&$c)->node_count,
            next : next_
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::sequenced_index_node<$T1> >*)(boost::multi_index::detail::sequenced_index_node<$T1>*)(boost::multi_index::detail::sequenced_index_node_trampoline<$T1>*)(&$e))->value
    )
  )
}
;---------------------------------------------------
; boost::multi_index_container - random access index
boost::multi_index::detail::header_holder<boost::multi_index::detail::random_access_index_node<*>,*>{
  preview(#("random access index"))
  children(
    #(
      #array(
          expr:  (($T2*)&$c)->ptrs.spc.data_[$i],
          size:  (($T2*)&$c)->node_count
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::random_access_index_node<$T1> >*)(boost::multi_index::detail::random_access_index_node<$T1>*)(boost::multi_index::detail::random_access_index_node_trampoline<$T1>*)&$e)->value
    )
  )
}
;--------------------------------------------
; boost::multi_index_container - hashed index
boost::multi_index::detail::header_holder<boost::multi_index::detail::hashed_index_node<*>,*>{
  preview(#("hashed index - ", (($T2*)&$c)->node_count, " in ", (($T2*)&$c)->buckets.size_, " buckets"))
  children(
    #(
      #array(
            expr : (($T2*)&$c)->buckets.spc.data_[$i],
            size : (($T2*)&$c)->buckets.size_
      ) : (msvc_helpers::multi_index_helper_3<boost::multi_index::detail::hashed_index_node<$T1> >*)(void*)&$e
    )
  )
}
msvc_helpers::multi_index_helper_3<boost::multi_index::detail::hashed_index_node<*> >{
  preview(#if ( ((boost::multi_index::detail::hashed_index_node_impl*)&$c)->next_==((boost::multi_index::detail::hashed_index_node_impl*)&$c) )
             ; no data at all
             (#("---"))
          #else (
             #if ( ((boost::multi_index::detail::hashed_index_node_impl*)&$c)->next_->next_==((boost::multi_index::detail::hashed_index_node_impl*)&$c) ) (
               ; 1 item: preview as _value_
               #( ((msvc_helpers::multi_index_helper<boost::multi_index::detail::hashed_index_node<$T1> >*)(boost::multi_index::detail::hashed_index_node<$T1>*)(boost::multi_index::detail::hashed_index_node_trampoline<$T1>*)(((boost::multi_index::detail::hashed_index_node_impl*)&$c)->next_))->value)
             ) #else (
               ; multiple items: preview as [_value_ ...]
               #("[", ((msvc_helpers::multi_index_helper<boost::multi_index::detail::hashed_index_node<$T1> >*)(boost::multi_index::detail::hashed_index_node<$T1>*)(boost::multi_index::detail::hashed_index_node_trampoline<$T1>*)(((boost::multi_index::detail::hashed_index_node_impl*)&$c)->next_))->value, " ...]")
             )
          )
         )
  children(
    #(
      ; multiple items: view as list
      #list(
        head: ((boost::multi_index::detail::hashed_index_node_impl*)&$c)->next_,
        next: next_,
        skip: ((boost::multi_index::detail::hashed_index_node_impl*)&$c)
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::hashed_index_node<$T1> >*)(boost::multi_index::detail::hashed_index_node<$T1>*)(boost::multi_index::detail::hashed_index_node_trampoline<$T1>*)(&$e))->value
    )
  )
}
;---------------------------------------------
; boost::multi_index_container - ordered index
boost::multi_index::detail::header_holder<boost::multi_index::detail::ordered_index_node<*>,*>{
  preview(#("ordered index"))
  children(
    #(
      #tree(
            head : *(boost::multi_index::detail::ordered_index_node_compressed_base*)(boost::multi_index::detail::ordered_index_node_impl*)(void*)(((boost::multi_index::detail::ordered_index_node_trampoline<$T1>*)($c.member))->parentcolor_&~1U),
            size : (($T2*)&$c)->node_count,
            left : left_,
            right : right_,
            skip : 0
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::ordered_index_node<$T1> >*)(boost::multi_index::detail::ordered_index_node<$T1>*)(boost::multi_index::detail::ordered_index_node_trampoline<$T1>*)(&$e))->value
    )
  )
}
;
; BOOST_VISUALIZER_END boost::multi_index_container
;--------------------------------------------------

;----------------------------------------------------
; BOOST_VISUALIZER_START boost::multi_index_container
;
; Copyright Filip Konvi?ka 2007 - 2009. Use, modification and distribution are subject
; to the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt
; or copy at http://www.boost.org/LICENSE_1_0.txt)
;
; @guid     CA3A7EDA-43F3-11DC-9D06-4B5856D89593
; @platform msvc-8, msvc-9
; @version  2.0
; @header   mic_visualizer.hpp
; @author   Filip Konvi?ka
; @email    filip dot konvicka at logis dot cz
;
; Usage
; =====
;
; This version is for Boost.MultiIndex versions 1.35 and above.
; The other version of this file is known to work for Boost.MultiIndex 1.34.1.
;
; Visualization must be explicitly enabled in the code for each type.
; For each multi_index_container type, you need to call
;
;   VISUALIZE_MULTI_INDEX_CONTAINER(TypeName);
;
; at global namespace level. The macro is defined in the accompanying header file mic_visualizer.hpp.
;
;
;------------------------------------
; boost::multi_index_container - base
;
; This passes control to the header_holder decoders :-)
boost::multi_index::multi_index_container<*,*,*>{
  preview(#($c.node_count, " items (multi_index_container)"))
  children(
    #(
      data:((msvc_helpers::multi_index_helper_2<boost::multi_index::multi_index_container<$T1,$T2,$T3> >*)&$c)->header,
      original members: [$c,!]
    )
  )
}
;-----------------------------------------------
; boost::multi_index_container - sequenced index
boost::multi_index::detail::header_holder<boost::multi_index::detail::sequenced_index_node<*>*,*>{
  preview(#("sequenced index"))
  children(
    #(
      #list(
            head : *(((boost::multi_index::detail::sequenced_index_node_trampoline<$T1>*)($c.member))->next_),
            size : (($T3*)&$c)->node_count,
            next : next_
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::sequenced_index_node<$T1> >*)(boost::multi_index::detail::sequenced_index_node<$T1>*)(boost::multi_index::detail::sequenced_index_node_trampoline<$T1>*)(&$e))->value
    )
  )
}
;---------------------------------------------------
; boost::multi_index_container - random access index
boost::multi_index::detail::header_holder<boost::multi_index::detail::random_access_index_node<*>*,*>{
  preview(#("random access index"))
  children(
    #(
      #array(
          expr:  (($T3*)&$c)->ptrs.spc.data_[$i],
          size:  (($T3*)&$c)->node_count
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::random_access_index_node<$T1> >*)(boost::multi_index::detail::random_access_index_node<$T1>*)(boost::multi_index::detail::random_access_index_node_trampoline<$T1>*)(&$e))->value
    )
  )
}
;--------------------------------------------
; boost::multi_index_container - hashed index
; NOTE: it seems that we don't need to retrieve the actual allocator used, std::allocator will suffice...
boost::multi_index::detail::header_holder<boost::multi_index::detail::hashed_index_node<*>*,*>{
  preview(#("hashed index - ", (($T3*)&$c)->node_count, " in ", (($T3*)&$c)->buckets.size_, " buckets"))
  children(
    #(
      #array(
            expr : (($T3*)&$c)->buckets.spc.data_[$i],
            size : (($T3*)&$c)->buckets.size_
      ) : *(msvc_helpers::multi_index_helper_3<boost::multi_index::detail::hashed_index_node<$T1> >*)(void*)&$e
    )
  )
}
msvc_helpers::multi_index_helper_3<boost::multi_index::detail::hashed_index_node<*> >{
  preview(#if ( ((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)->next_==((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c) )
             ; no data at all
             (#("---"))
          #else (
             #if ( ((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)->next_->next_==((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c) ) (
               ; 1 item: preview as _value_
               #( ((msvc_helpers::multi_index_helper<boost::multi_index::detail::hashed_index_node<$T1> >*)(boost::multi_index::detail::hashed_index_node<$T1>*)(boost::multi_index::detail::hashed_index_node_trampoline<$T1>*)(((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)->next_))->value)
             ) #else (
               ; multiple items: preview as [_value_ ...]
               #("[", ((msvc_helpers::multi_index_helper<boost::multi_index::detail::hashed_index_node<$T1> >*)(boost::multi_index::detail::hashed_index_node<$T1>*)(boost::multi_index::detail::hashed_index_node_trampoline<$T1>*)(((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)->next_))->value, " ...]")
             )
          )
         )
  children(
    #(
      ; multiple items: view as list
      #list(
        head: ((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)->next_,
        next: next_,
        skip: ((boost::multi_index::detail::hashed_index_node_impl<std::allocator<char> >*)&$c)
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::hashed_index_node<$T1> >*)(boost::multi_index::detail::hashed_index_node<$T1>*)(boost::multi_index::detail::hashed_index_node_trampoline<$T1>*)(&$e))->value
    )
  )
}
;---------------------------------------------
; boost::multi_index_container - ordered index
; NOTE: it seems that we don't need to retrieve the actual allocator used, std::allocator will suffice...
boost::multi_index::detail::header_holder<boost::multi_index::detail::ordered_index_node<*>*,*>{
  preview(#("ordered index"))
  children(
      #tree(
            head : *(boost::multi_index::detail::ordered_index_node_compressed_base<std::allocator<char> >*)(boost::multi_index::detail::ordered_index_node_impl<std::allocator<char> >*)(void*)(((boost::multi_index::detail::ordered_index_node_trampoline<$T1>*)($c.member))->parentcolor_&~1U),
            size : (($T3*)&$c)->node_count,
            left : left_,
            right : right_,
            skip : 0
      ) : ((msvc_helpers::multi_index_helper<boost::multi_index::detail::ordered_index_node<$T1> >*)(boost::multi_index::detail::ordered_index_node<$T1>*)(boost::multi_index::detail::ordered_index_node_trampoline<$T1>*)(&$e))->value
  )
}
;
; BOOST_VISUALIZER_END boost::multi_index_container
;--------------------------------------------------



;-------------------------------------------------------------
; BOOST_VISUALIZER_START boost::optional
;
; Copyright Daniel Kruegler 2008. Use, modification and distribution are subject to
; the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt
; or copy at http://www.boost.org/LICENSE_1_0.txt)
;
; @guid     D02681E0-021B-11DD-95FF-0800200C9A66
; @platform msvc-8, msvc-9
; @version  1.0
; @author   Daniel Kruegler
; @email    daniel dot kruegler at bdal dot de
;
; Usage
; =====
;
; All of the following text must be placed in the autoexp.dat file.
; Usage is automatic. No extra code is required.
;

boost::optional<*>|boost::optional_detail::optional_base<*> {
  preview
  (
    #if($e.m_initialized)
    (
      *(($T1 *) (&$e.m_storage.dummy_.data[0]))
    )
    #else
    (
      "?"
    )
  )
  
  children
  (
    #if($e.m_initialized)
    (
      #(value:
        *(($T1 *) (&$e.m_storage.dummy_.data[0]))
      )
    )
    #else
    (
      "?"
    )
  )
}

; BOOST_VISUALIZER_END boost::optional
;-----------------------------------------------------------


;-------------------------------------------------------------
; BOOST_VISUALIZER_START boost::ptr_container and boost::array
;
; Copyright William Buklis 2007. Use, modification and distribution are subject to
; the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt
; or copy at http://www.boost.org/LICENSE_1_0.txt)
;
; @guid     CDC4F187-4AE8-40f2-A1CA-4F5913BC2778
; @platform msvc-8, msvc-9
; @version  1.1
; @author   Bill Buklis
; @email    bill at pbjzone dot com
;
; Usage
; =====
;
; All of the following text must be placed in the autoexp.dat file.
; Usage is automatic. No extra code is required.
;
; The following containers are supported with these visualizers:
;	array
;	ptr_array
;	ptr_deque
;	ptr_list
;	ptr_map
;	ptr_multimap
;	ptr_set
;	ptr_multiset
;	ptr_vector
;
; All of these visualizers attempt to emulate their corresponding STL containers using
;	a pointer type. i.e. ptr_vector<T> displays equivalently to vector<T*>.
;


;------------------------------------------------------------------------------
;  boost::array
;------------------------------------------------------------------------------

boost::array<*,*>{
	preview( $c.elems )
	children
	(
	    #array
	    (
			expr:	$c.elems[$i],
			size :	$T2
		)
	)
}

;------------------------------------------------------------------------------
;  boost::ptr_array
;------------------------------------------------------------------------------

boost::ptr_array<*,*>{
	preview( ($T1**)$c.c_.elems )
	children
	(
	    #array
	    (
			expr:	($T1*)$c.c_.elems[$i],
			size :	$T2
		)
	)
}

;------------------------------------------------------------------------------
;  boost::ptr_vector
;------------------------------------------------------------------------------
boost::ptr_vector<*,*>{
	children
	(
	    #array
	    (
			expr: (($T1**)($c.c_._Myfirst))[$i],
			size :	$c.c_._Mylast-$c.c_._Myfirst
		)
	)
	
    preview
    ( 
        #( 
			"[", 
            $e.c_._Mylast - $e.c_._Myfirst, 
            "](", 
            
            #array
            (
				expr : 	(($T1**)($c.c_._Myfirst))[$i],  
				size : 	$c.c_._Mylast-$c.c_._Myfirst
			), 
			")"
		)
	)
}

;------------------------------------------------------------------------------
;  boost::ptr_map
;------------------------------------------------------------------------------

boost::ptr_map<*,*,*>{
	preview
	(
		#(
			"[", 
			$e.c_._Mysize, 
			"](", 

			#tree
			(
				head : $c.c_._Myhead->_Parent, 
				skip : $c.c_._Myhead, 
				size : $c.c_._Mysize, 
				left : _Left, 
				right : _Right
			) : *(std::pair<$T1,$T2 *> *)&($e._Myval),
			
			")"
		)
	)		     
	children
	(
		#tree
		(
			head : $c.c_._Myhead->_Parent,
		    skip : $c.c_._Myhead, 
		    size : $c.c_._Mysize, 
		    left : _Left, 
		    right : _Right
		) : *(std::pair<$T1,$T2 *> *)&($e._Myval)
	)
}

;------------------------------------------------------------------------------
;  boost::ptr_multimap
;------------------------------------------------------------------------------

boost::ptr_multimap<*,*,*>{
	preview
	(
		#(
			"[", 
			$e.c_._Mysize, 
			"](", 

			#tree
			(
				head : $c.c_._Myhead->_Parent, 
				skip : $c.c_._Myhead, 
				size : $c.c_._Mysize, 
				left : _Left, 
				right : _Right
			) : *(std::pair<$T1,$T2 *> *)&($e._Myval),
			
			")"
		)
	)		     
	children
	(
		#tree
		(
			head : $c.c_._Myhead->_Parent,
		    skip : $c.c_._Myhead, 
		    size : $c.c_._Mysize, 
		    left : _Left, 
		    right : _Right
		) : *(std::pair<$T1,$T2 *> *)&($e._Myval)
	)
}

boost::ptr_map_iterator<*,*,*>{
	preview
	( 
		#( "(", $c.m_iterator._Ptr->_Myval.first, ",", ($T3) $c.m_iterator._Ptr->_Myval.second, ")"
		)
	)
	children
	(
		#(
			_ptr: $c.m_iterator._Ptr,
			first: $c.m_iterator._Ptr->_Myval.first,
			second: ($T3) $c.m_iterator._Ptr->_Myval.second
		)
	)
}

;------------------------------------------------------------------------------
;  boost::ptr_set
;------------------------------------------------------------------------------

boost::ptr_set<*,*,*>{
    preview
    ( 
		#( 
			"[", 
            $e.c_._Mysize , 
            "](", 
            
            #tree
            (
				head : $c.c_._Myhead->_Parent, 
				skip : $c.c_._Myhead, 
				left : _Left, 
				right : _Right,
				size  : $c.c_._Mysize
			) : ($T1*)$e._Myval, 
			
			")"
		)
	)
			   
	children
	(
		#tree
		(
			head : $c.c_._Myhead->_Parent, 
			skip : $c.c_._Myhead, 
			left : _Left, 
			right : _Right,
			size  : $c.c_._Mysize
		) : ($T1*)$e._Myval
	)
}

;------------------------------------------------------------------------------
;  boost::ptr_multiset
;------------------------------------------------------------------------------

boost::ptr_multiset<*,*,*>{
    preview
    ( 
		#( 
			"[", 
            $e.c_._Mysize , 
            "](", 
            
            #tree
            (
				head : $c.c_._Myhead->_Parent, 
				skip : $c.c_._Myhead, 
				left : _Left, 
				right : _Right,
				size  : $c.c_._Mysize
			) : ($T1*)$e._Myval, 
			
			")"
		)
	)
			   
	children
	(
		#tree
		(
			head : $c.c_._Myhead->_Parent, 
			skip : $c.c_._Myhead, 
			left : _Left, 
			right : _Right,
			size  : $c.c_._Mysize
		) : ($T1*)$e._Myval
	)
}

;------------------------------------------------------------------------------
;  boost::ptr_list
;------------------------------------------------------------------------------

boost::ptr_list<*,*>{

	children
	(
		#list
		(
			head : ($c.c_._Myhead->_Next),
			size : $c.c_._Mysize, 
			next : _Next
		) : ($T1*)$e._Myval
	)
		          
	preview
	(
		#(
			"[", 
			$e._Mysize, 
			"](", 
		  
			#list
			(
				head : $c.c_._Myhead->_Next,
				size : $c.c_._Mysize, 
				next : _Next
			) : ($T1*)$e._Myval,
		 
			")"
		)
	)			      
}

;------------------------------------------------------------------------------
;  boost::ptr_deque
;------------------------------------------------------------------------------

boost::ptr_deque<*,*>{
	children
	(
		#array
		(
			expr : ($T1*)($c.c_._Map[ (($i + $c.c_._Myoff) / $c.c_._EEN_DS) % $c.c_._Mapsize][($i + $c.c_._Myoff) % $c.c_._EEN_DS]),
			size : $c.c_._Mysize
		)
	)

	preview
	(
		#(
			"[", 
			$e.c_._Mysize, 
			"](", 
		  
			#array
			(
				expr : ($T1*)($c.c_._Map[ (($i + $c.c_._Myoff) / $c.c_._EEN_DS) % $c.c_._Mapsize][($i + $c.c_._Myoff) % $c.c_._EEN_DS]),
				size : $c.c_._Mysize
			),
		 
			")"
		)
	)		       
}

;------------------------------------------------------------------------------
;  boost::ptr_vector::iterator (specialization of void_ptr_iterator)
;------------------------------------------------------------------------------
boost::void_ptr_iterator<std::_Vector_iterator<*>,*>|boost::void_ptr_iterator<std::_Vector_const_iterator<*>,*>{
	preview
	(
		#(
			($T2*)(*$c.iter_._Myptr)
		)
	)
	children
	(
		#(
			ptr: ($T2*)(*$c.iter_._Myptr)
		)
	)
}

;------------------------------------------------------------------------------
;  boost::ptr_deque::iterator (specialization of void_ptr_iterator)
;------------------------------------------------------------------------------
boost::void_ptr_iterator<std::_Deque_iterator<*,*,*>,*>|boost::void_ptr_iterator<std::_Deque_const_iterator<*,*,*>,*>{
   preview
   (
	   #if( $e.iter_._Myoff >= ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_Mysize)
	   (
	   		#("<end>")
	   )
	   #else(
			#(
				"deque[", 
				$e.iter_._Myoff - ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_Myoff, 
				"] = ",
				($T4*)((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_Map[ (($c.iter_._Myoff) / ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_Mapsize][$c.iter_._Myoff % ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_EEN_DS] 
			)
		)
	)
	children
	(
	   #if( ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_Mysize > $e.iter_._Myoff) 
	   (
			#(
				ptr: ($T4*)((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_Map[ ($c.iter_._Myoff / ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_Mapsize][$c.iter_._Myoff % ((std::deque<$T1,$T2 > *)$c.iter_._Mycont)->_EEN_DS] 
			)
		)
	)
}

;------------------------------------------------------------------------------
;  boost::ptr_array::iterator (specialization of void_ptr_iterator)
;------------------------------------------------------------------------------
boost::void_ptr_iterator<void**,*>{
	preview
	(
		#( ($T3**) $e.iter_ )
	)
	
	children
	(
		#( ptr: *($T3**) $e.iter_ )
	)
}

;------------------------------------------------------------------------------
;  boost::void_ptr_iterator - used by ptr_set, ptr_multiset, ptr_list
;------------------------------------------------------------------------------
boost::void_ptr_iterator<*,*>{
	preview
	(
		#( ($T2*) $e.iter_._Ptr->_Myval)
	)
	
	children
	(
		#(ptr: ($T2*) $e.iter_._Ptr->_Myval)
	)
}

; BOOST_VISUALIZER_END boost::ptr_container and boost::array
;-----------------------------------------------------------


;-----------------------------------------
; BOOST_VISUALIZER_START boost::shared_ptr
;
; Copyright Filip Konvi?ka 2009. Use, modification and distribution are subject
; to the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt
; or copy at http://www.boost.org/LICENSE_1_0.txt)
;
; @guid     CF808B30-203F-11DE-8C30-0800200C9A66
; @platform msvc-8, msvc-9
; @version  1.0
; @author   Filip Konvi?ka
; @email    filip dot konvicka at logis dot cz
;
; Usage
; =====
;
; This is a simple visualizer for shared_ptr (only shows the object or "null").

; boost::shared_ptr
boost::shared_ptr<*> {
  preview  (#if (!$e.px) (#("null")) #else (#(*$e.px, " (shared_ptr)")))
  children (#if (!$e.px) (#("null")) #else (*$e.px))
}

;
; BOOST_VISUALIZER_END boost::shared_ptr
;---------------------------------------




;--------------------------------------
; BOOST_VISUALIZER_START boost::variant
;
; Copyright Dmitry Vinogradov 2009. Use, modification and distribution are subject
; to the Boost Software License, Version 1.0. (See accompanying file LICENSE_1_0.txt
; or copy at http://www.boost.org/LICENSE_1_0.txt)
;
; @guid     28EEFD40-6353-11DE-8A39-0800200C9A66
; @platform msvc-8, msvc-9
; @version  1.0
; @author   Dmitry Vinogradov
; @email    sraider at yandex dot ru
;

; boost::variant
boost::variant<*,*,*,*,*,*,*,*,*,*,*> {
   preview (
       #(
           #switch($c.which_)
           #case 0 ( *($T1 *)&($c.storage_.data_) )
           #case 1 ( *($T2 *)&($c.storage_.data_) )
           #case 2 ( *($T3 *)&($c.storage_.data_) )
           #case 3 ( *($T4 *)&($c.storage_.data_) )
           #case 4 ( *($T5 *)&($c.storage_.data_) )
           #case 5 ( *($T6 *)&($c.storage_.data_) )
           #case 6 ( *($T7 *)&($c.storage_.data_) )
           #case 7 ( *($T8 *)&($c.storage_.data_) )
           #case 8 ( *($T9 *)&($c.storage_.data_) )
           #case 9 ( *($T10 *)&($c.storage_.data_) )
       )
   )
   children
   (
       #(
       value:
           #switch($c.which_)
           #case 0 ( *($T1 *)&($c.storage_.data_) )
           #case 1 ( *($T2 *)&($c.storage_.data_) )
           #case 2 ( *($T3 *)&($c.storage_.data_) )
           #case 3 ( *($T4 *)&($c.storage_.data_) )
           #case 4 ( *($T5 *)&($c.storage_.data_) )
           #case 5 ( *($T6 *)&($c.storage_.data_) )
           #case 6 ( *($T7 *)&($c.storage_.data_) )
           #case 7 ( *($T8 *)&($c.storage_.data_) )
           #case 8 ( *($T9 *)&($c.storage_.data_) )
           #case 9 ( *($T10 *)&($c.storage_.data_) )
       )
   )
} 

;
; BOOST_VISUALIZER_END boost::variant
;------------------------------------



;------------------------------------------------------------------------------
;  boost::basic_regex
;------------------------------------------------------------------------------

boost::basic_regex<*,*>{
	preview
	( 
		#(	"regex ",
			$c.m_pimpl.px->m_expression
		 )
	)
	children
	( 
		#( 
			internals: $c.m_pimpl.px
		)
	)
}



;------------------------------------------------------------------------------
;  boost::shared_ptr
;------------------------------------------------------------------------------

boost::shared_ptr<*>{
	preview
	( 
		#(	"shared_ptr ",
			(*(($T1 *)$c.px) )
			, " count = ", $c.pn.pi_->use_count_
		 )
	)
	children
	( 
		#( 
			ptr: (*(($T1 *)$c.px)) ,
			count: $c.pn.pi_->use_count_ ,
			weak_count: $c.pn.pi_->weak_count_
		)
	)
}


;------------------------------------------------------------------------------
;  boost::variant
;
;  Copyright (c) 2009 Dmitry Vinogradov
;  Copyright (c) 2009 Steven Watanabe
;
;  Distributed under the Boost Software License, Version 1.0. (See
;  accomapnying file LICENSE_1_0.txt or copy at
;  http://www.boost.org/LICENSE_1_0.txt)
;------------------------------------------------------------------------------

boost::variant<boost::detail::variant::over_sequence<*>,*> {
    preview ([$e,!])
    children (
        #(
            which_ : $e.which_,
            #(storage_ : $e.storage_)
        )
    )
}

boost::variant<boost::detail::variant::recursive_flag<boost::detail::variant::over_sequence<*> >,*> {
    preview ([$e,!])
    children (
        #(
            which_ : $e.which_,
            #(storage_ : $e.storage_)
        )
    )
}

boost::variant<boost::detail::variant::recursive_flag<*>,*,*,*,*,*,*,*,*,*>|boost::variant<*,*,*,*,*,*,*,*,*,*> {
    preview (
        #(
            #switch($e.which_)
            #case 0 ( *($T1 *)&($e.storage_.data_) )
            #case 1 ( *($T2 *)&($e.storage_.data_) )
            #case 2 ( *($T3 *)&($e.storage_.data_) )
            #case 3 ( *($T4 *)&($e.storage_.data_) )
            #case 4 ( *($T5 *)&($e.storage_.data_) )
            #case 5 ( *($T6 *)&($e.storage_.data_) )
            #case 6 ( *($T7 *)&($e.storage_.data_) )
            #case 7 ( *($T8 *)&($e.storage_.data_) )
            #case 8 ( *($T9 *)&($e.storage_.data_) )
            #case -1 ( **($T1 **)&($e.storage_.data_) )
            #case -2 ( **($T2 **)&($e.storage_.data_) )
            #case -3 ( **($T3 **)&($e.storage_.data_) )
            #case -4 ( **($T4 **)&($e.storage_.data_) )
            #case -5 ( **($T5 **)&($e.storage_.data_) )
            #case -6 ( **($T6 **)&($e.storage_.data_) )
            #case -7 ( **($T7 **)&($e.storage_.data_) )
            #case -8 ( **($T8 **)&($e.storage_.data_) )
            #case -9 ( **($T9 **)&($e.storage_.data_) )
            #default (#([actual members] : [$e,!]))
            #except (#([actual members] : [$e,!]))
        )
    )
    children
    (
        #(
        value :
            #switch($e.which_)
            #case 0 ( *($T1 *)&($e.storage_.data_) )
            #case 1 ( *($T2 *)&($e.storage_.data_) )
            #case 2 ( *($T3 *)&($e.storage_.data_) )
            #case 3 ( *($T4 *)&($e.storage_.data_) )
            #case 4 ( *($T5 *)&($e.storage_.data_) )
            #case 5 ( *($T6 *)&($e.storage_.data_) )
            #case 6 ( *($T7 *)&($e.storage_.data_) )
            #case 7 ( *($T8 *)&($e.storage_.data_) )
            #case 8 ( *($T9 *)&($e.storage_.data_) )
            #case -1 ( **($T1 **)&($e.storage_.data_) )
            #case -2 ( **($T2 **)&($e.storage_.data_) )
            #case -3 ( **($T3 **)&($e.storage_.data_) )
            #case -4 ( **($T4 **)&($e.storage_.data_) )
            #case -5 ( **($T5 **)&($e.storage_.data_) )
            #case -6 ( **($T6 **)&($e.storage_.data_) )
            #case -7 ( **($T7 **)&($e.storage_.data_) )
            #case -8 ( **($T8 **)&($e.storage_.data_) )
            #case -9 ( **($T9 **)&($e.storage_.data_) )
            #default ( *(void*)0 )
            #except ( *(void*)0 ),
            #([actual members] : [$e,!])
        )
    )
}

boost::recursive_wrapper<*> {
    preview ([*$e.p_])
}










;QT_DEBUG_START (Qt Visual Studio Add-in v1.1.9)
; Nokia Qt 4.x visualizers -----------------------------------------[ start ]--
;------------------------------------------------------------------------------
; Feel free to modify these visualizers to suit yours needs! But please let us
; know about the changes you make, so we continuously improve the visualizers.

QString|*::QString{
    preview         ([$e.d->data,su])
    stringview      ([$e.d->data,sub])
    children
    (
        #(
            d: $c.d,
            [size]: $c.d->size,
            [referenced]: $c.d->ref._q_value
        )
    )
}

QByteArray|*::QByteArray{
    preview         ([$e.d->data,s])
    stringview      ([$e.d->data,sb])
    children
    (
        #(
            d: $c.d,
            [size]: $c.d->size,
            [referenced]: $c.d->ref._q_value
        )
    )
}

QFileInfo|*::QFileInfo{
    preview
    (
        #(
            "private=", $c.d_ptr
        )
    )
}

QUrl|*::QUrl{
    preview
    (
        #if ($e.d.stateFlags == 0) (
            $e.d
        ) #else (
            #( $e.d->scheme, $e.d->host, $e.d->path )
        )
    )
    children
    (
        #(
            scheme: $c.d->scheme,
            host: $c.d->host,
            path: $c.d->path,
            username: $c.d->userName,
            password: $c.d->password,
            encodedOriginal: $c.d->encodedOriginal,
            query: $c.d->query,
            fragment: $c.d->fragment
        )
    )
}

QTime|*::QTime{
    preview
    (
        #(
            "hour=", [$e.mds / 3600000, d],
            ", minute=", [($e.mds % 3600000) / 60000, d],
            ", second=", [($e.mds / 1000) % 60, d],
            ", millisecond=", [$e.mds % 1000, d]
        )
    )
    children
    (
        #(
            [hour]: [$e.mds / 3600000, d],
            [minute]: [($e.mds % 3600000) / 60000, d],
            [second]: [($e.mds / 1000) % 60, d],
            [millisecond]: [$e.mds % 1000, d]
        )
    )
}

QVariant{
    preview
    (
        #if ($e.d.type == 1) (
            #("bool = ", [$e.d.data.b])
        ) #elif ($e.d.type == 2) (
            #("int = ", [$e.d.data.i])
        ) #elif ($e.d.type == 3) (
            #("usigned int = ", [$e.d.data.u])
        ) #elif ($e.d.type == 4) (
            #("long long = ", [$e.d.data.ll])
        ) #elif ($e.d.type == 5) (
            #("unsigned long long = ", [$e.d.data.ull])
        ) #elif ($e.d.type == 6) (
            #("double = ", [$e.d.data.d])
        ) #elif ($e.d.type == 7) (
            #("char = ", [$e.d.data.c])
        ) #elif ($e.d.type == 8) (
            #("QMap = ", [(QMap) $e.d.data.ptr])
        ) #elif ($e.d.type == 10) (
            #("QString = ", [(QString) $e.d.data.ptr])
        ) #elif ($e.d.type == 11) (
            #("QStringList = ", [(QStringList) $e.d.data.ptr])
        ) #elif ($e.d.type == 17) (
            #("QUrl = ", [(QUrl) $e.d.data.ptr])
        ) #else (
            #("type = ", [$e.d.type])
        )
    )
    children
    (
        #if ($e.d.type == 1) (
            $c.d.data.b
        ) #elif ($e.d.type == 2) (
            $c.d.data.i
        ) #elif ($e.d.type == 3) (
            $c.d.data.u
        ) #elif ($e.d.type == 4) (
            $c.d.data.ll
        ) #elif ($e.d.type == 5) (
            $c.d.data.ull
        ) #elif ($e.d.type == 6) (
            $c.d.data.d
        ) #elif ($e.d.type == 7) (
            $c.d.data.c
        ) #elif ($e.d.type == 8) (
        ) #elif ($e.d.type == 10) (
            #(
                [size]: ((QString) $c.d.data.ptr).d->size
            )
        ) #elif ($e.d.type == 11) (
            #if ((((QStringList) $e.d.data.ptr).d->end - ((QStringList) $e.d.data.ptr).d->begin) <= 10) (
               #array
               (
                    expr: (QString)((((QStringList) $e.d.data.ptr).d->array + ((QStringList) $e.d.data.ptr).d->begin)[$i]),
                    size: ((QStringList) $e.d.data.ptr).d->end-((QStringList) $e.d.data.ptr).d->begin
                )
            ) #else (
                #array
                (
                    expr: (QString)((((QStringList) $e.d.data.ptr).d->array + ((QStringList) $e.d.data.ptr).d->begin)[$i]),
                    size: 10
                )
            )
        ) #elif ($e.d.type == 17) (
            #(
                scheme: ((QUrl) $e.d.data.ptr).d->scheme,
                host: ((QUrl) $e.d.data.ptr).d->host,
                path: ((QUrl) $e.d.data.ptr).d->path,
                username: ((QUrl) $e.d.data.ptr).d->userName,
                password: ((QUrl) $e.d.data.ptr).d->password,
                encodedOriginal: ((QUrl) $e.d.data.ptr).d->encodedOriginal,
                query: ((QUrl) $e.d.data.ptr).d->query,
                fragment: ((QUrl) $e.d.data.ptr).d->fragment
            )
        ) #else (
            #("type = ", [$e.d.type])
        )
    )
}

*::QVariant{
    preview
    (
        #if ($e.d.type == 1) (
            #("bool = ", [$e.d.data.b])
        ) #elif ($e.d.type == 2) (
            #("int = ", [$e.d.data.i])
        ) #elif ($e.d.type == 3) (
            #("usigned int = ", [$e.d.data.u])
        ) #elif ($e.d.type == 4) (
            #("long long = ", [$e.d.data.ll])
        ) #elif ($e.d.type == 5) (
            #("unsigned long long = ", [$e.d.data.ull])
        ) #elif ($e.d.type == 6) (
            #("double = ", [$e.d.data.d])
        ) #elif ($e.d.type == 7) (
            #("char = ", [$e.d.data.c])
        ) #elif ($e.d.type == 8) (
            #("QMap = ", [($T1::QMap) $e.d.data.ptr])
        ) #elif ($e.d.type == 10) (
            #("QString = ", [($T1::QString) $e.d.data.ptr])
        ) #elif ($e.d.type == 11) (
            #("QStringList = ", [($T1::QStringList) $e.d.data.ptr])
        ) #elif ($e.d.type == 17) (
            #("QUrl = ", [($T1::QUrl) $e.d.data.ptr])
        ) #else (
            #("type = ", [$e.d.type])
        )
    )
    children
    (
        #if ($e.d.type == 1) (
            $c.d.data.b
        ) #elif ($e.d.type == 2) (
            $c.d.data.i
        ) #elif ($e.d.type == 3) (
            $c.d.data.u
        ) #elif ($e.d.type == 4) (
            $c.d.data.ll
        ) #elif ($e.d.type == 5) (
            $c.d.data.ull
        ) #elif ($e.d.type == 6) (
            $c.d.data.d
        ) #elif ($e.d.type == 7) (
            $c.d.data.c
        ) #elif ($e.d.type == 8) (
        ) #elif ($e.d.type == 10) (
            #(
                [size]: (($T1::QString) $c.d.data.ptr).d->size
            )
        ) #elif ($e.d.type == 11) (
            #if (((($T1::QStringList) $e.d.data.ptr).d->end - (($T1::QStringList) $e.d.data.ptr).d->begin) <= 10) (
               #array
               (
                    expr: ($T1::QString)(((($T1::QStringList) $e.d.data.ptr).d->array + (($T1::QStringList) $e.d.data.ptr).d->begin)[$i]),
                    size: (($T1::QStringList) $e.d.data.ptr).d->end-(($T1::QStringList) $e.d.data.ptr).d->begin
                )
            ) #else (
                #array
                (
                    expr: ($T1::QString)(((($T1::QStringList) $e.d.data.ptr).d->array + (($T1::QStringList) $e.d.data.ptr).d->begin)[$i]),
                    size: 10
                )
            )
        ) #elif ($e.d.type == 17) (
            #(
                scheme: (($T1::QUrl) $e.d.data.ptr).d->scheme,
                host: (($T1::QUrl) $e.d.data.ptr).d->host,
                path: (($T1::QUrl) $e.d.data.ptr).d->path,
                username: (($T1::QUrl) $e.d.data.ptr).d->userName,
                password: (($T1::QUrl) $e.d.data.ptr).d->password,
                encodedOriginal: (($T1::QUrl) $e.d.data.ptr).d->encodedOriginal,
                query: (($T1::QUrl) $e.d.data.ptr).d->query,
                fragment: (($T1::QUrl) $e.d.data.ptr).d->fragment
            )
        ) #else (
            #("type = ", [$e.d.type])
        )
    )
}

;------------------------------------------------------------------------------
; QStringList
;------------------------------------------------------------------------------
QStringList{
    preview
    (
        #if (($c.d->end - $c.d->begin) <= 10) (
            #(
                "[", $c.d->end - $c.d->begin, "](",
                #array
                (
                    expr: (QString)(($c.d->array + $c.d->begin)[$i]),
                    size: $c.d->end-$c.d->begin
                ), ")"
            )
        ) #else (
            #(
                "[", $c.d->end - $c.d->begin, "](",
                #array
                (
                    expr: (QString)(($c.d->array + $c.d->begin)[$i]),
                    size: 10
                ), ", ...)"
            )
        )
    )
}

*::QStringList{
    preview
    (
        #if (($c.d->end - $c.d->begin) <= 10) (
            #(
                "[", $c.d->end - $c.d->begin, "](",
                #array
                (
                    expr: ($T1::QString)(($c.d->array + $c.d->begin)[$i]),
                    size: $c.d->end-$c.d->begin
                ), ")"
            )
        ) #else (
            #(
                "[", $c.d->end - $c.d->begin, "](",
                #array
                (
                    expr: ($T1::QString)(($c.d->array + $c.d->begin)[$i]),
                    size: 10
                ), ", ...)"
            )
        )
    )
}

;------------------------------------------------------------------------------
; QList, QQueue
;------------------------------------------------------------------------------
QList<*>|QQueue<*>{
    preview
    (
        #if (int(sizeof($T1)) <= int(sizeof(void*))) (
            #if (($c.d->end - $c.d->begin) <= 10) (
                #(
                    "[", $c.d->end - $c.d->begin, "](",
                    #array
                    (
                        expr: ($T1)(($c.d->array + $c.d->begin)[$i]),
                        size: $c.d->end-$c.d->begin
                    ), ")"
                )
            ) #else (
                #(
                    "[", $c.d->end - $c.d->begin, "](",
                    #array
                    (
                        expr: ($T1)(($c.d->array + $c.d->begin)[$i]),
                        size: 10
                    ), ", ...)"
                )
            )
        ) #else (
            #if (($c.d->end - $c.d->begin) <= 10) (
                #(
                    "[", $c.d->end - $c.d->begin, "](",
                    #array
                    (
                        expr: *($T1*)(($c.d->array + $c.d->begin)[$i]),
                        size: $c.d->end-$c.d->begin
                    ), ")"
                )
            ) #else (
                #(
                    "[", $c.d->end - $c.d->begin, "](",
                    #array
                    (
                        expr: *($T1*)(($c.d->array + $c.d->begin)[$i]),
                        size: 10
                    ), ", ...)"
                )
            )
        )
    )
    children
    (
        #if (int(sizeof($T1)) <= int(sizeof(void*))) (
            #array (
                expr: ($T1)(($c.d->array + $c.d->begin)[$i]),
                size: $c.d->end - $c.d->begin
            )
        ) #else (
            #array (
                expr: *($T1*)(($c.d->array + $c.d->begin)[$i]),
                size: $c.d->end - $c.d->begin
            )
        )
    )
}

*::QList<*>|*::QQueue<*>{
    preview
    (
        #if (int(sizeof($T2)) <= int(sizeof(void*))) (
            #if (($c.d->end - $c.d->begin) <= 10) (
                #(
                    "[", $c.d->end - $c.d->begin, "](",
                    #array
                    (
                        expr: ($T2)(($c.d->array + $c.d->begin)[$i]),
                        size: $c.d->end-$c.d->begin
                    ), ")"
                )
            ) #else (
                #(
                    "[", $c.d->end - $c.d->begin, "](",
                    #array
                    (
                        expr: ($T2)(($c.d->array + $c.d->begin)[$i]),
                        size: 10
                    ), ", ...)"
                )
            )
        ) #else (
            #if (($c.d->end - $c.d->begin) <= 10) (
                #(
                    "[", $c.d->end - $c.d->begin, "](",
                    #array
                    (
                        expr: *($T2*)(($c.d->array + $c.d->begin)[$i]),
                        size: $c.d->end-$c.d->begin
                    ), ")"
                )
            ) #else (
                #(
                    "[", $c.d->end - $c.d->begin, "](",
                    #array
                    (
                        expr: *($T2*)(($c.d->array + $c.d->begin)[$i]),
                        size: 10
                    ), ", ...)"
                )
            )
        )
    )
    children
    (
        #if (int(sizeof($T2)) <= int(sizeof(void*))) (
            #array (
                expr: ($T2)(($c.d->array + $c.d->begin)[$i]),
                size: $c.d->end - $c.d->begin
            )
        ) #else (
            #array (
                expr: *($T2*)(($c.d->array + $c.d->begin)[$i]),
                size: $c.d->end - $c.d->begin
            )
        )
    )
}

;------------------------------------------------------------------------------
; QList::iterator, QQueue::iterator
;------------------------------------------------------------------------------
QList<*>::iterator|QList<*>::const_iterator|QQueue<*>::iterator|QQueue<*>::const_iterator{
    preview
    (
        #(
            ($T1*)$c.ptr
        )
    )
    children
    (
        #(
            ptr: ($T1)$c.ptr
        )
    )
}

*::QList<*>::iterator|*::QList<*>::const_iterator|*::QQueue<*>::iterator|*::QQueue<*>::const_iterator{
    preview
    (
        #(
            ($T2)$c.i->v
        )
    )
    children
    (
        #(
            ptr: ($T2)$c.i->v
        )
    )
}

;------------------------------------------------------------------------------
; QListIterator
;------------------------------------------------------------------------------
QListIterator<*>|QMutableListIterator<*>{
    preview
    (
        #(
            *($T1*)($c.i.i->v)
        )
    )
    children
    (
        #(
            Value: *($T1*)($c.i.i->v)
        )
    )
}

*::QListIterator<*>|*::QMutableListIterator<*>{
    preview
    (
        #(
            *($T2*)($c.i.i->v)
        )
    )
    children
    (
        #(
            Value: *($T2*)($c.i.i->v)
        )
    )
}

;------------------------------------------------------------------------------
; QLinkedList
;------------------------------------------------------------------------------
QLinkedList<*>{
    preview
    (
        #if ($e.d->size >= 10) (
            #(
                "[", $e.d->size, "](",
                #list
                (
                    head: $c.d->n,
                    size: 10,
                    next: n
                ) : ( (*(QLinkedListNode<$T1>*)&$e).t ), ", ...)"
            )
        ) #else (
            #(
                "[", $e.d->size, "](",
                #list
                (
                    head: $c.d->n,
                    size: $c.d->size,
                    next: n
                ) : ( (*(QLinkedListNode<$T1>*)&$e).t ), ")"
            )
        )
    )
    children
    (
        #(
            #list
            (
                head: $c.d->n,
                size: $c.d->size,
                next: n
            ) : (*(QLinkedListNode<$T1>*)&$e).t
        )
    )
}

*::QLinkedList<*>{
    preview
    (
        #if ($e.d->size >= 10) (
            #(
                "[", $e.d->size, "](",
                #list
                (
                    head: $c.d->n,
                    size: 10,
                    next: n
                ) : ( (*($T1::QLinkedListNode<$T2>*)&$e).t ), ", ...)"
            )
        ) #else (
            #(
                "[", $e.d->size, "](",
                #list
                (
                    head: $c.d->n,
                    size: $c.d->size,
                    next: n
                ) : ( (*($T1::QLinkedListNode<$T2>*)&$e).t ), ")"
            )
        )
    )
    children
    (
        #(
            #list
            (
                head: $c.d->n,
                size: $c.d->size,
                next: n
            ) : (*($T1::QLinkedListNode<$T2>*)&$e).t
        )
    )
}

;------------------------------------------------------------------------------
; QLinkedList::iterator
;------------------------------------------------------------------------------
QLinkedList<*>::iterator|*::QLinkedList<*>::iterator|QLinkedList<*>::const_iterator|*::QLinkedList<*>::const_iterator{
    preview
    (
        #(
            $e.i->t
        )
    )
    children
    (
        #(
            ptr: $e.i->t
        )
    )
}

QLinkedListIterator<*>|*::QLinkedListIterator<*>{
    preview
    (
        #(
            $c.i
        )
    )
    children
    (
        #(
            value: $c.i
        )
    )
}

;------------------------------------------------------------------------------
; QVector, QStack
;
; By default, this visualizer supports only Qt 4.6.x. If you're going to use
; Qt 4.5.x code, then you may want to replace all expr lines with this:
;    expr: (((size_t)($c.d) + (size_t)(sizeof(QVectorData)) ))[$i],
;
; This will allow this visualizer to display Qt 4.5.x and Qt 4.6.x QVector
; objects. But be aware of some limitations. For example enum types can't be
; displayed properly this way.
;
; Qt 4.5.x:
;     QVector::d is QVectorTypedData<T>
;     QVector::p is QVectorData
;     expr: $c.d->array[$i]
;
; Qt 4.6.x:
;     QVector::d is QVectorData
;     QVector::p is QVectorTypedData<T>
;     expr: $c.p->array[$i]
;
;------------------------------------------------------------------------------
QVector<*>|*::QVector<*>|QStack<*>|*::QStack<*>{
    preview
    (
        #if ($c.d->size <= 10) (
            #(
                "[", $c.d->size, "](",
                #array
                (
                    expr: $c.p->array[$i],
                    size: $c.d->size
                ), ")"
            )
        ) #else (
            #(
                "[", $c.d->size, "](",
                #array
                (
                    expr: $c.p->array[$i],
                    size: 10
                ), ", ...)"
            )
        )
    )
    children
    (
        #array
        (
            expr: $c.p->array[$i],
            size: $c.d->size
        )
    )
}

;------------------------------------------------------------------------------
; QMap
;------------------------------------------------------------------------------
QMapNode<*,*>{
    preview
    (
        #(
            "(",
            $e.key,
            "; ",
            $e.value,
            ")"
        )
    )

    children
    (
        #(
            key: $e.key,
            value: $e.value
        )
    )
}

QMap<*>{
    children
    (
        #(
            raw data: [$c,!],
            #tree
            (
                head : $c.d->forward[0],
                skip : $c.d,
                size : $c.d->size,
                left : backward,
                right : forward
            ) : ( (QMapNode<$T1>*)((char*)&$e - (sizeof(QMapPayloadNode<$T1>) - sizeof(QMapData::Node*))) )
        )
    )

    preview
    (
        #(
            "[",
            $e.d->size,
            "](",
                #tree
                (
                    head : $c.d->forward[0],
                    size : $c.d->size,
                    left : backward,
                    right : forward
                ) : $e,
            ")"
        )
    )
}

;------------------------------------------------------------------------------
; QHash
;------------------------------------------------------------------------------
QHash<*>{
    preview
    (
        #(
            "[", $e.d->size, "] (...)"
        )
    )
    children
    (
        #if ($e.d->size <= 255) (
            #(
                #array (
                    expr: (QHashNode<$T1>*)$c.d->buckets[$i],
                    size: $c.d->numBuckets
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e
                )
            )
        ) #else (
            #(
                #array (
                    expr: (QHashNode<$T1>*)$c.d->buckets[$i],
                    size: 255
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e
                )
            )
        )
    )
}

*::QHash<*>{
    preview
    (
        #(
             "[", $e.d->size, "] (...)"
        )
    )
    children
    (
        #if ($e.d->size <= 255) (
            #(
                #array (
                    expr: ($T1::QHashNode<$T2> *)$c.d->buckets[$i],
                    size: $c.d->numBuckets
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e
                )
            )
        ) #else (
            #(
                #array (
                    expr: ($T1::QHashNode<$T2> *)$c.d->buckets[$i],
                    size: 255
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e
                )
            )
        )
    )
}

;------------------------------------------------------------------------------
; QMultiHash
;------------------------------------------------------------------------------
QMultiHash<*>{
    preview
    (
        (*(QHash<$T1>*)(&$c))
    )
}

*::QMultiHash<*>{
    preview
    (
        (*($T1::QHash<$T2>*)(&$c))
    )
}

;------------------------------------------------------------------------------
; QHash::iterator
;------------------------------------------------------------------------------
QHash<*>::iterator{
    preview
    (
        #(
            "(", ((QHashNode<$T1>*)($c.i))->key, ", ", ((QHashNode<$T1>*)($c.i))->value, ")"
        )
    )
    children
    (
        #(
            key: ((QHashNode<$T1>*)($c.i))->key,
            value: ((QHashNode<$T1>*)($c.i))->value
        )
    )
}

*::QHash<*>::iterator{
    preview
    (
        #(
            "(", (($T1::QHashNode<$T2>*)($c.i))->key, ", ", (($T1::QHashNode<$T2>*)($c.i))->key, ")"
        )
    )
    children
    (
        #(
            key: (($T1::QHashNode<$T2>*)($c.i))->key,
            value: (($T1::QHashNode<$T2>*)($c.i))->value
        )
    )
}

;------------------------------------------------------------------------------
; QHashIterator
;------------------------------------------------------------------------------
QHashIterator<*>{
    preview
    (
        #(
            "(", ((QHashNode<$T1>*)((($c).i).i))->key, ", ", ((QHashNode<$T1>*)((($c).i).i))->key, ")"
        )
    )
    children
    (
        #(
            key: ((QHashNode<$T1>*)((($c).i).i))->key,
            value: ((QHashNode<$T1>*)((($c).i).i))->value
        )
    )
}

*::QHashIterator<*>{
    preview
    (
        #(
            "(", (($T1::QHashNode<$T2>*)((($c).i).i))->key, ", ", (($T1::QHashNode<$T2>*)((($c).i).i))->key, ")"
        )
    )
    children
    (
        #(
            key: (($T1::QHashNode<$T2>*)((($c).i).i))->key,
            value: (($T1::QHashNode<$T2>*)((($c).i).i))->value
        )
    )
}

;------------------------------------------------------------------------------
; QHashNode
;------------------------------------------------------------------------------
QHashNode<*>|*::QHashNode<*>{
    preview
    (
        #(
            "(key = ", $c.key,"; value = ", $c.value, ")"
        )
    )
    children
    (
        #(
            key: $c.key,
            value: $c.value
        )
    )
}

;------------------------------------------------------------------------------
; QSet
;------------------------------------------------------------------------------
QSet<*>{
    preview
    (
        #(
             "[", $e.q_hash.d->size, "] (...)"
        )
    )
    children
    (
        #if ($e.q_hash.d->size <= 255) (
            #(
                #array (
                    expr: (QHashNode<$T1,QHashDummyValue> *)$c.q_hash.d->buckets[$i],
                    size: $c.q_hash.d->numBuckets
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e.key
                )
            )
        ) #else (
            #(
                #array (
                    expr: (QHashNode<$T1,QHashDummyValue> *)$c.q_hash.d->buckets[$i],
                    size: 255
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e.key
                )
            )
        )
    )
}

*::QSet<*>{
    preview
    (
        #(
             "[", $e.q_hash.d->size, "] (...)"
        )
    )
    children
    (
        #if ($e.q_hash.d->size <= 255) (
            #(
                #array (
                    expr: ($T1::QHashNode<$T2,QHashDummyValue> *)$c.q_hash.d->buckets[$i],
                    size: $c.q_hash.d->numBuckets
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e.key
                )
            )
        ) #else (
            #(
                #array (
                    expr: ($T1::QHashNode<$T2,QHashDummyValue> *)$c.q_hash.d->buckets[$i],
                    size: 255
                ) : #list (
                    head: $e,
                    next: next
                ) : #switch ($e.next != 0) #case 1 (
                    $e.key
                )
            )
        )
    )
}

;------------------------------------------------------------------------------
; QPalette
;------------------------------------------------------------------------------
QPalette{
    children
    (
        #(
            WindowText_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 0)->d,
            Button_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 1)->d,
            Light_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 2)->d,
            Midlight_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 3)->d,
            Dark_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 4)->d,
            Mid_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 5)->d,
            Text_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 6)->d,
            BrightText_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 7)->d,
            ButtonText_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 8)->d,
            Base_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 9)->d,
            Window_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+10)->d,
            Shadow_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+11)->d,
            Highlight_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+12)->d,
            HighlightedText_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+13)->d,
            Link_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+14)->d,
            LinkVisited_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+15)->d,
            AlternateBase_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+16)->d,
            NoRole_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+17)->d,
            ToolTipBase_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+18)->d,
            ToolTipText_active:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+19)->d,

            WindowText_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 0)->d,
            Button_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 1)->d,
            Light_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 2)->d,
            Midlight_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 3)->d,
            Dark_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 4)->d,
            Mid_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 5)->d,
            Text_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 6)->d,
            BrightText_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 7)->d,
            ButtonText_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 8)->d,
            Base_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 9)->d,
            Window_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+10)->d,
            Shadow_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+11)->d,
            Highlight_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+12)->d,
            HighlightedText_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+13)->d,
            Link_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+14)->d,
            LinkVisited_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+15)->d,
            AlternateBase_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+16)->d,
            NoRole_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+17)->d,
            ToolTipBase_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+18)->d,
            ToolTipText_disabled:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+19)->d,

            WindowText_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 0)->d,
            Button_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 1)->d,
            Light_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 2)->d,
            Midlight_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 3)->d,
            Dark_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 4)->d,
            Mid_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 5)->d,
            Text_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 6)->d,
            BrightText_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 7)->d,
            ButtonText_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 8)->d,
            Base_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 9)->d,
            Window_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+10)->d,
            Shadow_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+11)->d,
            Highlight_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+12)->d,
            HighlightedText_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+13)->d,
            Link_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+14)->d,
            LinkVisited_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+15)->d,
            AlternateBase_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+16)->d,
            NoRole_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+17)->d,
            ToolTipBase_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+18)->d,
            ToolTipText_inactive:
                ((QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+19)->d
        )
    )
}

*::QPalette{
    children
    (
        #(
            WindowText_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 0)->d,
            Button_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 1)->d,
            Light_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 2)->d,
            Midlight_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 3)->d,
            Dark_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 4)->d,
            Mid_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 5)->d,
            Text_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 6)->d,
            BrightText_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 7)->d,
            ButtonText_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 8)->d,
            Base_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+ 9)->d,
            Window_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+10)->d,
            Shadow_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+11)->d,
            Highlight_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+12)->d,
            HighlightedText_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+13)->d,
            Link_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+14)->d,
            LinkVisited_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+15)->d,
            AlternateBase_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+16)->d,
            NoRole_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+17)->d,
            ToolTipBase_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+18)->d,
            ToolTipText_active:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+19)->d,

            WindowText_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 0)->d,
            Button_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 1)->d,
            Light_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 2)->d,
            Midlight_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 3)->d,
            Dark_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 4)->d,
            Mid_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 5)->d,
            Text_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 6)->d,
            BrightText_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 7)->d,
            ButtonText_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 8)->d,
            Base_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+ 9)->d,
            Window_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+10)->d,
            Shadow_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+11)->d,
            Highlight_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+12)->d,
            HighlightedText_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+13)->d,
            Link_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+14)->d,
            LinkVisited_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+15)->d,
            AlternateBase_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+16)->d,
            NoRole_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+17)->d,
            ToolTipBase_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+18)->d,
            ToolTipText_disabled:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+20+19)->d,

            WindowText_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 0)->d,
            Button_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 1)->d,
            Light_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 2)->d,
            Midlight_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 3)->d,
            Dark_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 4)->d,
            Mid_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 5)->d,
            Text_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 6)->d,
            BrightText_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 7)->d,
            ButtonText_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 8)->d,
            Base_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+ 9)->d,
            Window_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+10)->d,
            Shadow_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+11)->d,
            Highlight_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+12)->d,
            HighlightedText_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+13)->d,
            Link_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+14)->d,
            LinkVisited_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+15)->d,
            AlternateBase_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+16)->d,
            NoRole_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+17)->d,
            ToolTipBase_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+18)->d,
            ToolTipText_inactive:
                (($T1::QBrush*)((char*)$c.d+sizeof(QAtomicInt))+40+19)->d
        )
    )
}

;------------------------------------------------------------------------------
; QBrush
;------------------------------------------------------------------------------
QBrush|*::QBrush{
    preview
    (
        #(
            "[", $c.d->style, "] (...)"
        )
    )
    children
    (
        #(
            style: $c.d->style,
            color: $c.d->color,
            transform: $c.d->transform
        )
    )
}

QBrushData|*::QBrushData{
    preview
    (
        #(
            "[", $c.style, "] (...)"
        )
    )
    children
    (
        #(
            style: $c.style,
            color: $c.color,
            transform: $c.transform
        )
    )
}

;------------------------------------------------------------------------------
; QColor
;------------------------------------------------------------------------------
QColor|*::QColor{
    preview
    (
        #(
            #if ($c.cspec == 1) (
                #(
                    "[", $c.cspec, "] [", "r = ", [$c.ct.argb.red,x],
                                          ", g = ", [$c.ct.argb.green,x],
                                          ", b = ", [$c.ct.argb.blue,x], "] (...)"
                )
            ) #elif ($c.cspec == 2) (
                #(
                    "[", $c.cspec, "] [", "h = ", [$c.ct.ahsv.hue,x],
                                          ", s = ", [$c.ct.ahsv.saturation,x],
                                          ", v = ", [$c.ct.ahsv.value,x], "] (...)"
                )
            ) #elif ($c.cspec == 3) (
                #(
                    "[", $c.cspec, "] [", "c = ", [$c.ct.acmyk.cyan,x],
                                          ", m = ", [$c.ct.acmyk.magenta,x],
                                          ", y = ", [$c.ct.acmyk.yellow,x],
                                          ", k = ", [$c.ct.acmyk.black,x], "] (...)"
                )
            ) #else (
                #(
                    "[Invalid]"
                )
            )
        )
    )
    children
    (
        #(
            #if ($c.cspec == 1) (
                #(
                    red: [$c.ct.argb.red,x],
                    green: [$c.ct.argb.green,x],
                    blue: [$c.ct.argb.blue,x],
                    alpha: [$c.ct.argb.alpha,x],
            pad: [$c.ct.argb.pad,x]
                )
            ) #elif ($c.cspec == 2) (
                #(
                    hue: [$c.ct.ahsv.hue,x],
                    saturation: [$c.ct.ahsv.saturation,x],
                    value: [$c.ct.ahsv.value,x],
                    alpha: [$c.ct.ahsv.alpha,x],
            pad: [$c.ct.ahsv.pad,x]                    
                )
            ) #elif ($c.cspec == 3) (
                #(
                    cyan: [$c.ct.acmyk.cyan,x],
                    magenta: [$c.ct.acmyk.magenta,x],
                    yellow: [$c.ct.acmyk.yellow,x],
                    black: [$c.ct.acmyk.black,x],
                    alpha: [$c.ct.acmyk.alpha,x]
                )
            )
        )
    )
}

;------------------------------------------------------------------------------
; QTransform
;------------------------------------------------------------------------------
QTransform|*::QTransform{
    preview
    (
        #(
            "[",[$c.affine._m11,g]," ",[$c.affine._m12,g]," ",[$c.m_13,g],"]", 
            "[",[$c.affine._m21,g]," ",[$c.affine._m22,g]," ",[$c.m_23,g],"]",
            "[",[$c.affine._dx,g]," ",[$c.affine._dy,g]," ",[$c.m_33,g],"]"
        )
    )
    children
    (
        #(
            translation_horizontal_m31_dx: [$c.affine._dx,g],
            translation_vertical_m32_dy: [$c.affine._dy,g],
            scaling_horizontal_m11: [$c.affine._m11,g],
            scaling_vertical_m22: [$c.affine._m22,g],
            projection_factor_m33: [$c.m_33,g],
            projection_horizontal_m13: [$c.m_13,g],
            projection_vertical_m23: [$c.m_23,g],
            shearing_horizontal_m21: [$c.affine._m21,g],
            shearing_vertical_m12: [$c.affine._m12,g],
            type: $c.m_type,
            dirty: (bool)$c.m_dirty
        )
    )
}

;------------------------------------------------------------------------------
; QMatrix
;------------------------------------------------------------------------------
QMatrix|*::QMatrix{
    preview
    (
        #(
            "[",[$c._m11,g]," ",[$c._m12,g],"]", 
            "[",[$c._m21,g]," ",[$c._m22,g],"]",
            "[",[$c._dx,g]," ",[$c._dy,g],"]"
        )
    )
    children
    (
        #(
            translation_horizontal_dx: [$c._dx,g],
            translation_vertical_dy: [$c._dy,g],
            scaling_horizontal_m11: [$c._m11,g],
            scaling_vertical_m22: [$c._m22,g],
            shearing_horizontal_m21: [$c._m21,g],
            shearing_vertical_m12: [$c._m12,g]
        )
    )
}

;------------------------------------------------------------------------------
; QPolygon
;------------------------------------------------------------------------------
QPolygon{
    preview
    (
        #(
             "[", ((QVector<QPoint>*)(&$c))->d->size, "] (...)"
        )
    )
    children
    (
        #(
            #array
            (
                expr: ((QPoint*)(((void*)$c.d) + sizeof(QVectorData)))[$i],
                size: ((QVector<QPoint>*)(&$c))->d->size
            )
        )
    )
}
*::QPolygon{
    preview
    (
        #(
             "[", (($T1::QVector<$T1::QPoint>*)(&$c))->d->size, "] (...)"
        )
    )
    children
    (
        #(
            #array
            (
                expr: (($T1::QPoint*)(((void*)$c.d) + sizeof(QVectorData)))[$i],
                size: (($T1::QVector<$T1::QPoint>*)(&$c))->d->size
            )
        )
    )
}

;------------------------------------------------------------------------------
; QPolygonF
;------------------------------------------------------------------------------
QPolygonF{
    preview
    (
        #(
             "[", ((QVector<QPointF>*)(&$c))->d->size, "] (...)"
        )
    )
    children
    (
        #(
            #array
            (
                expr: ((QVector<QPointF>*)(&$c))->p->array[$i],
                size: ((QVector<QPointF>*)(&$c))->d->size
            )
        )
    )
}

*::QPolygonF{
    preview
    (
        #(
             "[", (($T1::QVector<$T1::QPointF>*)(&$c))->d->size, "] (...)"
        )
    )
    children
    (
        #(
            #array
            (
                expr: (($T1::QVector<$T1::QPointF>*)(&$c))->p->array[$i],
                size: (($T1::QVector<$T1::QPointF>*)(&$c))->d->size
            )
        )
    )
}

;------------------------------------------------------------------------------
; Nokia Qt 4.x visualizers -------------------------------------------[ end ]--
;QT_DEBUG_END
; This section contains visualizers for STL and ATL containers
; DO NOT MODIFY
ATL::CStringT<char,*>|CSimpleStringT<char,*>|ATL::CSimpleStringT<char,*>{
		preview			([$e.m_pszData,s])
		stringview		([$e.m_pszData,sb])
}
ATL::CStringT<wchar_t,*>|CSimpleStringT<wchar_t,*>|ATL::CSimpleStringT<wchar_t,*>|ATL::CStringT<unsigned short,*>|CSimpleStringT<unsigned short,*>|ATL::CSimpleStringT<unsigned short,*>{
		preview			([$e.m_pszData,su])
		stringview		([$e.m_pszData,sub])
}
ATL::CComBSTR{
		preview			([$e.m_str,su])
		stringview		([$e.m_str,sub])
}











; Many TR1 visualizers use nested #()s.
; Why not use #(foo, bar) instead of #(#(foo), #(bar))?
; The former alphabetically sorts its fields, while the latter does not.
;------------------------------------------------------------------------------
;  std::tr1::reference_wrapper
;------------------------------------------------------------------------------
std::tr1::reference_wrapper<*>{
	preview (
		#if ($e._Callee._EEN_INDIRECT == 1) (
			; For ordinary T, reference_wrapper<T> stores a T * _Callee._Ptr
			; which is non-null. Actual references are previewed with what they
			; refer to, so reference_wrapper<T> is previewed with dereferencing its
			; stored pointer.
			*$e._Callee._Ptr
		) #else (
			; When T is a pointer to function, pointer to member function,
			; or pointer to data member type, reference_wrapper<T> stores a
			; T _Callee._Object directly.
			$e._Callee._Object
		)
	)

	children (
		#if ($e._Callee._EEN_INDIRECT == 1) (
			; Actual references have the same children as what they refer to.
			; Unfortunately, there appears to be no way to imitate this exactly.
			; Therefore, we make reference_wrapper<T> appear to have a single
			; child, its stored pointer, with a fake name of [ptr].
			#([ptr] : $e._Callee._Ptr)
		) #else (
			; When T is a pointer to function, pointer to member function,
			; or pointer to data member type, T has no children, so we make
			; reference_wrapper<T> appear to have no children.
			#array(expr: 0, size: 0)
		)
	)
}
;------------------------------------------------------------------------------
;  std::tr1::shared_ptr
;------------------------------------------------------------------------------
std::tr1::shared_ptr<*>{
	preview (
		; shared_ptr<T> stores a T * _Ptr .
		#if ($e._Ptr == 0) (
			; A default-constructed shared_ptr has a null _Ptr and a null _Rep,
			; and is formally said to be empty.
			; A shared_ptr constructed from a null pointer has a null _Ptr
			; and a NON-null _Rep . It is formally said to own the null pointer.
			; We preview both with "empty".
			"empty"
		) #else (
			; Raw pointers are previewed with "<pointer value> <object>".
			; auto_ptr is previewed with "auto_ptr <object>".
			; Following these examples, shared_ptr is previewed with
			; "shared_ptr <object> [N strong refs, M weak refs]".
			#(
				"shared_ptr ",
				*$e._Ptr,
				" [",
				$e._Rep->_Uses,
				#if ($e._Rep->_Uses == 1) (" strong ref") #else (" strong refs"),
				#if ($e._Rep->_Weaks - 1 > 0) (
					#(
						", ",
						$e._Rep->_Weaks - 1,
						#if ($e._Rep->_Weaks - 1 == 1) (" weak ref") #else (" weak refs")
					)
				),
				"]"
			)
			; Note: _Rep->_Uses counts how many shared_ptrs share ownership of the object,
			; so we directly display it as the strong reference count.
			; _Rep->_Weaks counts how many shared_ptrs and weak_ptrs share ownership of
			; the "representation object" (or "control block"). All of the shared_ptrs are
			; counted as a single owner. That is, _Weaks is initialized to 1, and when
			; _Uses falls to 0, _Weaks is decremented. This avoids incrementing and decrementing
			; _Weaks every time that a shared_ptr gains or loses ownership. Therefore,
			; _Weaks - 1 is the weak reference count, the number of weak_ptrs that are observing
			; the shared object.
		)
	)

	children (
		#if ($e._Ptr == 0) (
			; We make empty shared_ptrs (and shared_ptrs that own
			; the null pointer) appear to have no children.
			#array(expr: 0, size: 0)
		) #else (
			#(
				; We make shared_ptr appear to have a single child,
				; its stored pointer, with a fake name of [ptr].
				#([ptr] : $e._Ptr),

				; Visualizers can't determine whether a shared_ptr has a custom deleter.
				; Therefore, we also show the actual members.
				; Look at what std::tr1::shared_ptr<T> > [actual members] > std::tr1::_Ptr_base<T> > _Rep points to.
				; Default deleter: std::tr1::_Ref_count<T>
				;  Custom deleter: std::tr1::_Ref_count_d<T, D> > _Dtor
				#([actual members] : [$e,!])
			)
		)
	)
}













boost::shared_ptr<*>{
    preview (
        ; shared_ptr<T> stores a T * px .
        #if ($e.px == 0) (
            ; A default-constructed shared_ptr has a null px.
            ; We preview with "empty".
            "empty"
        ) #else (
            ; Raw pointers are previewed with "<pointer value> <object>".
            ; auto_ptr is previewed with "auto_ptr <object>".
            ; Following these examples, shared_ptr is previewed with
            ; "shared_ptr <object> [N strong refs, M weak refs]".
            #(
                "shared_ptr ",
                *$e.px,
                " [",
                $e.pn.pi_->use_count_,
                #if ($e.pn.pi_->use_count_ == 1) (" strong ref") #else (" strong refs"),
                #if ($e.pn.pi_->weak_count_ - 1 > 0) (
                    #(
                        ", ",
                        $e.pn.pi_->weak_count_ - 1,
                        #if ($e.pn.pi_->weak_count_ - 1 == 1) (" weak ref") #else (" weak refs")
                    )
                ),
                "]"
            )
        )
    )

    children (
        #if ($e.px == 0) (
            ; We make empty shared_ptrs (and shared_ptrs that own
            ; the null pointer) appear to have no children.
            #array(expr: 0, size: 0)
        ) #else (
            #(
                ; We make shared_ptr appear to have a single child,
                ; its stored pointer, with a fake name of [ptr].
                #([ptr] : $e.px),

                ; Visualizers can't determine whether a shared_ptr has a custom deleter.
                ; Therefore, we also show the actual members.
                #([actual members] : [$e,!])
            )
        )
    )
}






;------------------------------------------------------------------------------
;  std::tr1::weak_ptr
;------------------------------------------------------------------------------
std::tr1::weak_ptr<*>{
	preview (
		#if ($e._Ptr == 0) (
			"empty"
		) #elif ($e._Rep->_Uses == 0) (
			; weak_ptr is just like shared_ptr, except that a weak_ptr can be expired.
			"expired"
		) #else (
			#(
				"weak_ptr ",
				*$e._Ptr,
				" [",
				$e._Rep->_Uses,
				#if ($e._Rep->_Uses == 1) (" strong ref") #else (" strong refs"),
				#if ($e._Rep->_Weaks - 1 > 0) (
					#(
						", ",
						$e._Rep->_Weaks - 1,
						#if ($e._Rep->_Weaks - 1 == 1) (" weak ref") #else (" weak refs")
					)
				),
				"]"
			)
		)
	)

	children (
		#if ($e._Ptr == 0) (
			#array(expr: 0, size: 0)
		) #elif ($e._Rep->_Uses == 0) (
			; When a weak_ptr is expired, we make it appear to have no children.
			#array(expr: 0, size: 0)
		) #else (
			#(
				#([ptr] : $e._Ptr),
				#([actual members] : [$e,!])
			)
		)
	)
}
;------------------------------------------------------------------------------
;  std::tr1::tuple
;------------------------------------------------------------------------------
; tuple is visualized like pair, except that we have to give fake names to tuple's children.
std::tr1::tuple<std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil>{
	preview (
		"()"
	)

	children (
		#array(expr: 0, size: 0)
	)
}
std::tr1::tuple<*,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil>{
	preview (
		#(
			"(", $e._Impl._Value,
			")"
		)
	)

	children (
		#(
			[0] : $e._Impl._Value
		)
	)
}
std::tr1::tuple<*,*,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil>{
	preview (
		#(
			"(", $e._Impl._Value,
			",", $e._Impl._Tail._Value,
			")"
		)
	)

	children (
		#(
			[0] : $e._Impl._Value,
			[1] : $e._Impl._Tail._Value
		)
	)
}
std::tr1::tuple<*,*,*,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil>{
	preview (
		#(
			"(", $e._Impl._Value,
			",", $e._Impl._Tail._Value,
			",", $e._Impl._Tail._Tail._Value,
			")"
		)
	)

	children (
		#(
			[0] : $e._Impl._Value,
			[1] : $e._Impl._Tail._Value,
			[2] : $e._Impl._Tail._Tail._Value
		)
	)
}
std::tr1::tuple<*,*,*,*,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil>{
	preview (
		#(
			"(", $e._Impl._Value,
			",", $e._Impl._Tail._Value,
			",", $e._Impl._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Value,
			")"
		)
	)

	children (
		#(
			[0] : $e._Impl._Value,
			[1] : $e._Impl._Tail._Value,
			[2] : $e._Impl._Tail._Tail._Value,
			[3] : $e._Impl._Tail._Tail._Tail._Value
		)
	)
}
std::tr1::tuple<*,*,*,*,*,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil>{
	preview (
		#(
			"(", $e._Impl._Value,
			",", $e._Impl._Tail._Value,
			",", $e._Impl._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Value,
			")"
		)
	)

	children (
		#(
			[0] : $e._Impl._Value,
			[1] : $e._Impl._Tail._Value,
			[2] : $e._Impl._Tail._Tail._Value,
			[3] : $e._Impl._Tail._Tail._Tail._Value,
			[4] : $e._Impl._Tail._Tail._Tail._Tail._Value
		)
	)
}
std::tr1::tuple<*,*,*,*,*,*,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil>{
	preview (
		#(
			"(", $e._Impl._Value,
			",", $e._Impl._Tail._Value,
			",", $e._Impl._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Value,
			")"
		)
	)

	children (
		#(
			[0] : $e._Impl._Value,
			[1] : $e._Impl._Tail._Value,
			[2] : $e._Impl._Tail._Tail._Value,
			[3] : $e._Impl._Tail._Tail._Tail._Value,
			[4] : $e._Impl._Tail._Tail._Tail._Tail._Value,
			[5] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Value
		)
	)
}
std::tr1::tuple<*,*,*,*,*,*,*,std::tr1::_Nil,std::tr1::_Nil,std::tr1::_Nil>{
	preview (
		#(
			"(", $e._Impl._Value,
			",", $e._Impl._Tail._Value,
			",", $e._Impl._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			")"
		)
	)

	children (
		#(
			[0] : $e._Impl._Value,
			[1] : $e._Impl._Tail._Value,
			[2] : $e._Impl._Tail._Tail._Value,
			[3] : $e._Impl._Tail._Tail._Tail._Value,
			[4] : $e._Impl._Tail._Tail._Tail._Tail._Value,
			[5] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Value,
			[6] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Value
		)
	)
}
std::tr1::tuple<*,*,*,*,*,*,*,*,std::tr1::_Nil,std::tr1::_Nil>{
	preview (
		#(
			"(", $e._Impl._Value,
			",", $e._Impl._Tail._Value,
			",", $e._Impl._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			")"
		)
	)

	children (
		#(
			[0] : $e._Impl._Value,
			[1] : $e._Impl._Tail._Value,
			[2] : $e._Impl._Tail._Tail._Value,
			[3] : $e._Impl._Tail._Tail._Tail._Value,
			[4] : $e._Impl._Tail._Tail._Tail._Tail._Value,
			[5] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Value,
			[6] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			[7] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value
		)
	)
}
std::tr1::tuple<*,*,*,*,*,*,*,*,*,std::tr1::_Nil>{
	preview (
		#(
			"(", $e._Impl._Value,
			",", $e._Impl._Tail._Value,
			",", $e._Impl._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			")"
		)
	)

	children (
		#(
			[0] : $e._Impl._Value,
			[1] : $e._Impl._Tail._Value,
			[2] : $e._Impl._Tail._Tail._Value,
			[3] : $e._Impl._Tail._Tail._Tail._Value,
			[4] : $e._Impl._Tail._Tail._Tail._Tail._Value,
			[5] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Value,
			[6] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			[7] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			[8] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value
		)
	)
}
std::tr1::tuple<*,*,*,*,*,*,*,*,*,*>{
	preview (
		#(
			"(", $e._Impl._Value,
			",", $e._Impl._Tail._Value,
			",", $e._Impl._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			",", $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			")"
		)
	)

	children (
		#(
			[0] : $e._Impl._Value,
			[1] : $e._Impl._Tail._Value,
			[2] : $e._Impl._Tail._Tail._Value,
			[3] : $e._Impl._Tail._Tail._Tail._Value,
			[4] : $e._Impl._Tail._Tail._Tail._Tail._Value,
			[5] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Value,
			[6] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			[7] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			[8] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value,
			[9] : $e._Impl._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Tail._Value
		)
	)
}
;------------------------------------------------------------------------------
;  std::tr1::array
;------------------------------------------------------------------------------
std::tr1::array<*>{
	preview (
		; An actual array is previewed with its address.
		; array<T, N> is previewed like vector<T>.
		#(
			"[",
			$e._EEN_SIZE,
			"](",
			#array(expr: $e._Elems[$i], size: $e._EEN_SIZE),
			")"
		)
	)

	children (
		; Just like an actual array.
		#array(expr: $e._Elems[$i], size: $e._EEN_SIZE)
	)
}
std::tr1::_Array_iterator<*>|std::tr1::_Array_const_iterator<*>{
	preview (
		#if ($e._Idx == $e._EEN_SIZE) (
			; array iterators are represented by _Ptr + _Idx,
			; and they know how large their parent arrays are. Therefore, detecting
			; end iterators is trivial.
			"end"
		) #else (
			; Like vector iterators, array iterators are previewed with what they point to.
			$e._Ptr[$e._Idx]
		)
	)

	children (
		#if ($e._Idx == $e._EEN_SIZE) (
			; We make end iterators appear to have no children.
			#array(expr: 0, size: 0)
		) #else (
			; An array iterator is conceptually a pointer, so we make it appear to store one.
			#([ptr] : $e._Ptr + $e._Idx)
		)
	)
}
;------------------------------------------------------------------------------
;  std::tr1::function
;------------------------------------------------------------------------------
std::tr1::function<*>{
	preview (
		#if ($e._Impl == 0) (
			; Detecting empty functions is trivial.
			"empty"
		) #else (
			; The only thing that we can preview non-empty
			; functions with is the fact that they are non-empty.
			"full"
		)
	)

	children (
		#if ($e._Impl == 0) (
			; We make empty functions appear to have no children.
			#array(expr: 0, size: 0)
		) #else (
			; The callee is stored in (vaguely speaking) $e._Impl->_Callee._Object,
			; but visualizers can't show this. Therefore, we show the actual members.
			#([actual members] : [$e,!])
		)
	)
}
;------------------------------------------------------------------------------
;  std::tr1::unordered_set
;  std::tr1::unordered_multiset
;  std::tr1::unordered_map
;  std::tr1::unordered_multimap
;------------------------------------------------------------------------------
; See the stdext::hash_set visualizer.
;------------------------------------------------------------------------------
;  std::tr1::basic_regex
;------------------------------------------------------------------------------
std::tr1::basic_regex<*>{
	preview (
		#if ($e._Rep == 0) (
			; Default construction creates an empty basic_regex.
			"empty"
		) #elif ($e._EEN_VIS == 1) (
			; By default, _ENHANCED_REGEX_VISUALIZER is defined to be 1 in debug and 0 in ship.
			; When it is 1, basic_regex stores the string from which it was constructed.
			; When it is 0, basic_regex stores only the resulting finite state machine.
			$e._Visualization
		) #else (
			; basic_regex contains many static const flags, which would be shown in the preview by default.
			; Its actual members are _Rep and _Traits. _Rep holds the finite state machine, so we
			; use it to preview basic_regex. (It does contain some human-readable information.)
			*$e._Rep
		)
	)

	children (
		#if ($e._Rep == 0) (
			; We make empty basic_regexes appear to have no children.
			#array(expr: 0, size: 0)
		) #elif ($e._EEN_VIS == 1) (
			; We want to hide those static const flags.
			; We also want to give _Visualization a fake name.
			#(
				#([str] : $e._Visualization),
				#(_Rep : $e._Rep),
				#(_Traits : $e._Traits)
			)
		) #else (
			; We want to hide those static const flags.
			#(
				_Rep : $e._Rep,
				_Traits : $e._Traits
			)
		)
	)
}
;------------------------------------------------------------------------------
;  std::tr1::sub_match
;------------------------------------------------------------------------------
std::tr1::sub_match<char const *>|std::tr1::sub_match<wchar_t const *>|std::tr1::sub_match<unsigned short const *>{
	preview (
		; It would be nice if we could preview sub_match with its str().
		; However, visualizers cannot handle strings represented by pointer pairs.
		; Therefore, our preview contains more limited information.
		#if ($e.matched) (
			; If this sub_match participated in a match,
			; we preview it with its length().
			$e.second - $e.first
		) #else (
			; Otherwise, we preview it with its matched bool (i.e. "false").
			; (Why not length() (i.e. "0")? It's meaningful to have
			; matched == true and length() == 0.
			"false"
		)
	)

	children (
		#(
			; sub_match's three data members are public, but we list them here
			; (a) to display matched before first and second, and
			; (b) to gloss over the fact that sub_match derives from std::pair.
			#(matched : $e.matched),
			#(first : $e.first),
			#(second : $e.second)
		)
	)
}
std::tr1::sub_match<std::_String_const_iterator<*> >{
	preview (
		#if ($e.matched) (
			; We visualize ssub_match and wssub_match just like csub_match and wcsub_match,
			; except that when determining the length(), we can't subtract iterators.
			; We have to subtract their stored pointers.
			$e.second._Myptr - $e.first._Myptr
		) #else (
			"false"
		)
	)

	children (
		#(
			#(matched : $e.matched),
			#(first : $e.first),
			#(second : $e.second)
		)
	)
}
;------------------------------------------------------------------------------
;  std::tr1::match_results
;------------------------------------------------------------------------------
std::tr1::match_results<*>{
	preview (
		; A match_results object is empty iff its vector _Matches is empty.
		#if ($e._Matches._Myfirst == $e._Matches._Mylast) (
			"empty"
		) #else (
			; We preview a non-empty match_results object with its vector.
			$e._Matches
		)
	)

	children (
		#if ($e._Matches._Myfirst == $e._Matches._Mylast) (
			; We make empty match_results appear to have no children.
			#array(expr: 0, size: 0)
		) #else (
			; As match_results has operator[](), prefix(), and suffix() member functions,
			; we make it appear to directly contain [0], [1], [2], etc. elements,
			; as well as [prefix] and [suffix] elements.
			#(
				#array(expr: $e._Matches._Myfirst[$i], size: $e._Matches._Mylast - $e._Matches._Myfirst),
				#([prefix] : $e._Prefix),
				#([suffix] : $e._Suffix)
			)
		)
	)
}
;------------------------------------------------------------------------------
;  std::tr1::mem_fn()
;------------------------------------------------------------------------------
; Note that when mem_fn() is given a data member pointer, it returns a _Call_wrapper<_Callable_pmd<*> > .
; Data member pointers themselves don't have useful previews, so we don't attempt to visualize this.
; When mem_fn() is given a member function pointer, it returns a _Mem_fn[N], which we can visualize.
std::tr1::_Mem_fn1<*>|std::tr1::_Mem_fn2<*>|std::tr1::_Mem_fn3<*>|std::tr1::_Mem_fn4<*>|std::tr1::_Mem_fn5<*>|std::tr1::_Mem_fn6<*>|std::tr1::_Mem_fn7<*>|std::tr1::_Mem_fn8<*>|std::tr1::_Mem_fn9<*>|std::tr1::_Mem_fn10<*>{
	preview (
		; We preview the functor returned by mem_fn() with its stored member function pointer.
		$e._Callee._Object
	)

	children (
		; Member function pointers have no children.
		#array(expr: 0, size: 0)
	)
}
;------------------------------------------------------------------------------
;  std::tr1::regex_iterator
;------------------------------------------------------------------------------
std::tr1::regex_iterator<*>{
	preview (
		#if ($e._MyRe == 0) (
			; We represent end-of-sequence regex_iterators with null regex pointers.
			"end"
		) #else (
			; Dereferenceable regex_iterators return match_results when dereferenced,
			; so we'll preview them with that.
			$e._MyVal
		)
	)

	children (
		#if ($e._MyRe == 0) (
			; We make end-of-sequence regex_iterators appear to have no children.
			#array(expr: 0, size: 0)
		) #else (
			; For ease of understanding, we make dereferenceable regex_iterators
			; appear to have data members with the "for exposition only" names from TR1.
			#(
				#([begin] : $e._Begin),
				#([end] : $e._End),
				#([pregex] : $e._MyRe),
				#([flags] : $e._Flags),
				#([match] : $e._MyVal)
			)
		)
	)
}
;------------------------------------------------------------------------------
;  std::tr1::regex_token_iterator
;------------------------------------------------------------------------------
std::tr1::regex_token_iterator<*>{
	preview (
		#if ($e._Res == 0) (
			; We represent end-of-sequence regex_token_iterators with null result pointers.
			"end"
		) #else (
			; Dereferenceable regex_token_iterators return *result when dereferenced,
			; so we'll preview them with that.
			*$e._Res
		)
	)

	children (
		#if ($e._Res == 0) (
			; We make end-of-sequence regex_token_iterators appear to have no children.
			#array(expr: 0, size: 0)
		) #else (
			; For ease of understanding, we make dereferenceable regex_token_iterators
			; appear to have data members with the "for exposition only" names from TR1.
			#(
				#([position] : $e._Pos),
				#([result] : $e._Res),
				#([suffix] : $e._Suffix),
				#([N] : $e._Cur),
				#([subs] : $e._Subs)
			)
		)
	)
}

;------------------------------------------------------------------------------
;  std::tr1::bind()
;------------------------------------------------------------------------------

; STL functors are previewed with their names.
; They have no state, so they have no children.
std::plus<*>{
	preview ( "plus" )
	children ( #array(expr: 0, size: 0) )
}
std::minus<*>{
	preview ( "minus" )
	children ( #array(expr: 0, size: 0) )
}
std::multiplies<*>{
	preview ( "multiplies" )
	children ( #array(expr: 0, size: 0) )
}
std::divides<*>{
	preview ( "divides" )
	children ( #array(expr: 0, size: 0) )
}
std::modulus<*>{
	preview ( "modulus" )
	children ( #array(expr: 0, size: 0) )
}
std::negate<*>{
	preview ( "negate" )
	children ( #array(expr: 0, size: 0) )
}
std::equal_to<*>{
	preview ( "equal_to" )
	children ( #array(expr: 0, size: 0) )
}
std::not_equal_to<*>{
	preview ( "not_equal_to" )
	children ( #array(expr: 0, size: 0) )
}
std::greater<*>{
	preview ( "greater" )
	children ( #array(expr: 0, size: 0) )
}
std::less<*>{
	preview ( "less" )
	children ( #array(expr: 0, size: 0) )
}
std::greater_equal<*>{
	preview ( "greater_equal" )
	children ( #array(expr: 0, size: 0) )
}
std::less_equal<*>{
	preview ( "less_equal" )
	children ( #array(expr: 0, size: 0) )
}
std::logical_and<*>{
	preview ( "logical_and" )
	children ( #array(expr: 0, size: 0) )
}
std::logical_or<*>{
	preview ( "logical_or" )
	children ( #array(expr: 0, size: 0) )
}
std::logical_not<*>{
	preview ( "logical_not" )
	children ( #array(expr: 0, size: 0) )
}

; STL function pointer adaptors are previewed with "ptr_fun(<stored function pointer>)".
; Function pointers have no children, so the adaptors have no children.
std::pointer_to_unary_function<*>|std::pointer_to_binary_function<*>{
	preview (
		#(
			"ptr_fun(",
			$e._Pfun,
			")"
		)
	)

	children ( #array(expr: 0, size: 0) )
}

; STL negators are previewed with "not[12](<stored functor>)".
; They have a child with the fake name of [pred], so that the
; stored functor can be inspected.
std::unary_negate<*>{
	preview (
		#(
			"not1(",
			$e._Functor,
			")"
		)
	)

	children (
		#([pred] : $e._Functor)
	)
}
std::binary_negate<*>{
	preview (
		#(
			"not2(",
			$e._Functor,
			")"
		)
	)

	children (
		#([pred] : $e._Functor)
	)
}

; bind() placeholders are previewed with their names.
; They have no state, so they have no children.
std::tr1::_Ph<1>{
	preview ( "_1" )
	children ( #array(expr: 0, size: 0) )
}
std::tr1::_Ph<2>{
	preview ( "_2" )
	children ( #array(expr: 0, size: 0) )
}
std::tr1::_Ph<3>{
	preview ( "_3" )
	children ( #array(expr: 0, size: 0) )
}
std::tr1::_Ph<4>{
	preview ( "_4" )
	children ( #array(expr: 0, size: 0) )
}
std::tr1::_Ph<5>{
	preview ( "_5" )
	children ( #array(expr: 0, size: 0) )
}
std::tr1::_Ph<6>{
	preview ( "_6" )
	children ( #array(expr: 0, size: 0) )
}
std::tr1::_Ph<7>{
	preview ( "_7" )
	children ( #array(expr: 0, size: 0) )
}
std::tr1::_Ph<8>{
	preview ( "_8" )
	children ( #array(expr: 0, size: 0) )
}
std::tr1::_Ph<9>{
	preview ( "_9" )
	children ( #array(expr: 0, size: 0) )
}
std::tr1::_Ph<10>{
	preview ( "_10" )
	children ( #array(expr: 0, size: 0) )
}

; The functor returned by bind(f, t1, t2) is previewed with "bind(f, t1, t2)".
; It has children with the fake names of [f], [t1], [t2], etc.
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind0<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object)
		)
	)
}
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind1<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0)
		)
	)
}
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind2<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1)
		)
	)
}
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind3<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2)
		)
	)
}
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind4<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3)
		)
	)
}
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind5<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4)
		)
	)
}
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind6<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			", ", $e._Bx._Vx5,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4),
			#([t6] : $e._Bx._Vx5)
		)
	)
}
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind7<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			", ", $e._Bx._Vx5,
			", ", $e._Bx._Vx6,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4),
			#([t6] : $e._Bx._Vx5),
			#([t7] : $e._Bx._Vx6)
		)
	)
}
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind8<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			", ", $e._Bx._Vx5,
			", ", $e._Bx._Vx6,
			", ", $e._Bx._Vx7,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4),
			#([t6] : $e._Bx._Vx5),
			#([t7] : $e._Bx._Vx6),
			#([t8] : $e._Bx._Vx7)
		)
	)
}
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind9<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			", ", $e._Bx._Vx5,
			", ", $e._Bx._Vx6,
			", ", $e._Bx._Vx7,
			", ", $e._Bx._Vx8,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4),
			#([t6] : $e._Bx._Vx5),
			#([t7] : $e._Bx._Vx6),
			#([t8] : $e._Bx._Vx7),
			#([t9] : $e._Bx._Vx8)
		)
	)
}
std::tr1::_Bind<std::tr1::_Notforced,std::tr1::_Bind10<*> >{
	preview (
		#(
			"bind(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			", ", $e._Bx._Vx5,
			", ", $e._Bx._Vx6,
			", ", $e._Bx._Vx7,
			", ", $e._Bx._Vx8,
			", ", $e._Bx._Vx9,
			")"
		)
	)

	children (
		#(
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4),
			#([t6] : $e._Bx._Vx5),
			#([t7] : $e._Bx._Vx6),
			#([t8] : $e._Bx._Vx7),
			#([t9] : $e._Bx._Vx8),
			#([t10] : $e._Bx._Vx9)
		)
	)
}

; The functor returned by bind<RetType>(f, t1, t2) is previewed with "bind<R>(f, t1, t2)",
; because we cannot stringify a type name into the preview.
; Its first child has the fake name of [R *] and is a null pointer of type RetType *.
; This allows RetType to be found easily, instead of digging through the bound functor's type.
; This is followed by children with the fake names of [f], [t1], [t2], etc.
std::tr1::_Bind<*,std::tr1::_Bind0<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object)
		)
	)
}
std::tr1::_Bind<*,std::tr1::_Bind1<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0)
		)
	)
}
std::tr1::_Bind<*,std::tr1::_Bind2<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1)
		)
	)
}
std::tr1::_Bind<*,std::tr1::_Bind3<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2)
		)
	)
}
std::tr1::_Bind<*,std::tr1::_Bind4<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3)
		)
	)
}
std::tr1::_Bind<*,std::tr1::_Bind5<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4)
		)
	)
}
std::tr1::_Bind<*,std::tr1::_Bind6<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			", ", $e._Bx._Vx5,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4),
			#([t6] : $e._Bx._Vx5)
		)
	)
}
std::tr1::_Bind<*,std::tr1::_Bind7<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			", ", $e._Bx._Vx5,
			", ", $e._Bx._Vx6,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4),
			#([t6] : $e._Bx._Vx5),
			#([t7] : $e._Bx._Vx6)
		)
	)
}
std::tr1::_Bind<*,std::tr1::_Bind8<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			", ", $e._Bx._Vx5,
			", ", $e._Bx._Vx6,
			", ", $e._Bx._Vx7,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4),
			#([t6] : $e._Bx._Vx5),
			#([t7] : $e._Bx._Vx6),
			#([t8] : $e._Bx._Vx7)
		)
	)
}
std::tr1::_Bind<*,std::tr1::_Bind9<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			", ", $e._Bx._Vx5,
			", ", $e._Bx._Vx6,
			", ", $e._Bx._Vx7,
			", ", $e._Bx._Vx8,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4),
			#([t6] : $e._Bx._Vx5),
			#([t7] : $e._Bx._Vx6),
			#([t8] : $e._Bx._Vx7),
			#([t9] : $e._Bx._Vx8)
		)
	)
}
std::tr1::_Bind<*,std::tr1::_Bind10<*> >{
	preview (
		#(
			"bind<R>(", $e._Bx._Callee._Object,
			", ", $e._Bx._Vx0,
			", ", $e._Bx._Vx1,
			", ", $e._Bx._Vx2,
			", ", $e._Bx._Vx3,
			", ", $e._Bx._Vx4,
			", ", $e._Bx._Vx5,
			", ", $e._Bx._Vx6,
			", ", $e._Bx._Vx7,
			", ", $e._Bx._Vx8,
			", ", $e._Bx._Vx9,
			")"
		)
	)

	children (
		#(
			#([R *] : ($T1 *) 0),
			#([f] : $e._Bx._Callee._Object),
			#([t1] : $e._Bx._Vx0),
			#([t2] : $e._Bx._Vx1),
			#([t3] : $e._Bx._Vx2),
			#([t4] : $e._Bx._Vx3),
			#([t5] : $e._Bx._Vx4),
			#([t6] : $e._Bx._Vx5),
			#([t7] : $e._Bx._Vx6),
			#([t8] : $e._Bx._Vx7),
			#([t9] : $e._Bx._Vx8),
			#([t10] : $e._Bx._Vx9)
		)
	)
}

;------------------------------------------------------------------------------
;  std::vector<bool,*> specialization
;------------------------------------------------------------------------------
std::vector<bool,*>{
	children
	(
		#array
		(
			expr : ($e._Myvec._Myfirst[$i / _VBITS] >> ($i % _VBITS)),
			size : ($e._Mysize)
		)  : (bool)($e & 1)
	)
	preview
	(
		#(
			"[", $e._Mysize , "](",
			#array
			(
				expr : ($e._Myvec._Myfirst[$i / _VBITS] >> ($i % _VBITS)),
				size : ($e._Mysize)
			)  : (bool)($e & 1),
			")"
		)
	)
}
std::vector<bool,*>::iterator|std::vector<bool,*>::const_iterator|std::_Vb_iterator<*>|std::_Vb_const_iterator<*>{
	preview		( #( (bool) (((*$e._Myptr) >> $e._Myoff) & 1)))
	children	( #( ptr: (bool) (((*$e._Myptr) >> $e._Myoff) & 1)))
}
;------------------------------------------------------------------------------
;  std::vector
;------------------------------------------------------------------------------
std::vector<*>{
	children
	(
		#array
		(
			expr :		($e._Myfirst)[$i],
			size :		$e._Mylast-$e._Myfirst
		)
	)
	preview
	(
		#(
			"[", $e._Mylast - $e._Myfirst , "](",
			#array
			(
				expr :	($e._Myfirst)[$i],
				size :	$e._Mylast-$e._Myfirst
			),
			")"
		)
	)
}
std::_Vector_iterator<*>|std::_Vector_const_iterator<*>{
	preview		( #(*$e._Myptr))
	children	( #(ptr: *$e._Myptr))
}
;------------------------------------------------------------------------------
;  std::string/basic_string
;------------------------------------------------------------------------------
std::basic_string<char,*>{
	preview		( #if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,s]) #else ( [$e._Bx._Ptr,s]))
	stringview	( #if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,sb]) #else ( [$e._Bx._Ptr,sb]))
	children
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			#([actual members]: [$e,!] , #array( expr: $e._Bx._Buf[$i], size: $e._Mysize))
		)
		#else
		(
			#([actual members]: [$e,!],  #array( expr: $e._Bx._Ptr[$i], size: $e._Mysize))
		)
	)
}
std::basic_string<unsigned short,*>|std::basic_string<wchar_t,*>{
	preview
	(
		#if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,su] )
		#else ( [$e._Bx._Ptr,su] )
	)
	stringview
	(
		#if(($e._Myres) < ($e._BUF_SIZE)) ( [$e._Bx._Buf,sub] )
		#else ( [$e._Bx._Ptr,sub] )
	)
	children
	(
		#if(($e._Myres) < ($e._BUF_SIZE))
		(
			#(
				[actual members]: [$e,!] ,
				#array( expr: $e._Bx._Buf[$i], size: $e._Mysize)
			)
		)
		#else
		(
			#(
				[actual members]: [$e,!],
				#array( expr: $e._Bx._Ptr[$i], size: $e._Mysize)
			)
		)
	)
}
std::basic_string<*>::iterator|std::basic_string<*>::const_iterator|std::_String_iterator<*>|std::_String_const_iterator<*>{
		preview ( #( $e._Myptr ))
		children ( #( ptr: $e._Myptr ))
}
std::pair<*>{
	preview ( #( "(", $e.first, ",", $e.second , ")"))
}
;------------------------------------------------------------------------------
;  std::auto_ptr
;------------------------------------------------------------------------------
std::auto_ptr<*>{
	preview
	(
		#(
			"auto_ptr ",
			(*(($T1 *)$e._Myptr))
		 )
	)
	children
	(
		#(
			ptr: (*(($T1 *)$e._Myptr))
		)
	)
}
;------------------------------------------------------------------------------
;  std::map
;------------------------------------------------------------------------------
std::map<*>{
	children
	(
		#tree
		(
			head : $e._Myhead->_Parent,
			skip : $e._Myhead,
			size : $e._Mysize,
			left : _Left,
			right : _Right
		) : $e._Myval
	)
	preview
	(
		#(
			"[", $e._Mysize, "](",
			#tree
			(
				head : $e._Myhead->_Parent,
				skip : $e._Myhead,
				size : $e._Mysize,
				left : _Left,
				right : _Right
			) : $e._Myval,
			")"
		)
	)
}
;------------------------------------------------------------------------------
;  std::multi_map
;------------------------------------------------------------------------------
std::multimap<*>{
	children
	(
		#tree
		(
			head : $e._Myhead->_Parent,
			skip : $e._Myhead,
			size : $e._Mysize,
			left : _Left,
			right : _Right
		) : $e._Myval
	)
	preview
	(
		#(
			"[", $e._Mysize, "](",
			#tree
			(
				head : $e._Myhead->_Parent,
				skip : $e._Myhead,
				size : $e._Mysize,
				left : _Left,
				right : _Right
			) : $e._Myval,
			")"
		)
	)
}
;------------------------------------------------------------------------------
;  std::list
;------------------------------------------------------------------------------
std::list<*>{
	children
	(
		#list
		(
			head : $e._Myhead->_Next,
			size : $e._Mysize,
			next : _Next
		) : $e._Myval
	)
	preview
	(
		#(
			"[", $e._Mysize, "](",
			#list
			(
				head : $e._Myhead->_Next,
				size : $e._Mysize,
				next : _Next
			) : $e._Myval,
			")"
		)
	)
}
std::list<*>::iterator|std::list<*>::const_iterator|std::list<*>::_Iterator<1>|std::list<*>::_Const_iterator<1>{
	preview ( #($e._Ptr->_Myval))
	children ( #(ptr: $e._Ptr->_Myval))
}
;------------------------------------------------------------------------------
;  std::bitset	<bitset>
;------------------------------------------------------------------------------
std::bitset<*>{
	preview
	(
		#(
			"[", $e.digits, "](",
			#array
			(
				expr :	($e._Array[$i / $e._Bitsperword] >> ($i % $e._Bitsperword)),
				size :	$e.digits
			) : [($e & 1),d],
			")"
		)
	)
	children
	(
		#array
		(
			expr :	($e._Array[$i / $e._Bitsperword] >> ($i % $e._Bitsperword)),
			size :	$e.digits
		) : (bool)($e & 1)
	)
}
std::bitset<*>::reference{
	preview
	(
		#(
			"bitset[", $e._Mypos, "] = ",
			(bool)(($e._Pbitset->_Array[$i / _Bitsperword] >> ($e._Mypos % _Bitsperword)) & 1)
		)
	)
}
;------------------------------------------------------------------------------
;  std::deque
;------------------------------------------------------------------------------
std::deque<*>{
	children
	(
		#array
		(
			expr : $e._Map[ (($i + $e._Myoff) / $e._EEN_DS) % $e._Mapsize][($i + $e._Myoff) % $e._EEN_DS],
			size : $e._Mysize
		)
	)
	preview
	(
		#(
			"[", $e._Mysize, "](",
			#array
			(
				expr : $e._Map[ (($i + $e._Myoff) / $e._EEN_DS) % $e._Mapsize][($i + $e._Myoff) % $e._EEN_DS],
				size : $e._Mysize
			),
			")"
		)
	)
}
std::deque<*,*>::iterator|std::_Deque_iterator<*,*,*>|std::_Deque_const_iterator<*,*,*>{
	preview
	(
		#if( $e._EEN_HID == 0 )
		(
			#if( $e._Myoff >= ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Myoff + ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Mysize)
			(
				#("<end>")
			)
			#else
			(
				#(
					"deque[",
					$e._Myoff - ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Myoff,
					"] = ",
					((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Map[ (($e._Myoff) / ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_EEN_DS) % ((std::deque<$T1,$T2 > *)$e._Myaux->_Mycontainer)->_Mapsize][$e._Myoff % ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_EEN_DS]
				)
			)
		)
		#else
		(
			#if( $e._Myoff >= ((std::deque<$T1,$T2 > *)$e._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$e._Mycont)->_Mysize)
			(
				#("<end>")
			)
			#else
			(
				#(
					"deque[",
					$e._Myoff - ((std::deque<$T1,$T2 > *)$e._Mycont)->_Myoff,
					"] = ",
					((std::deque<$T1,$T2 > *)$e._Mycont)->_Map[ (($e._Myoff) / ((std::deque<$T1,$T2 > *)$e._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$e._Mycont)->_Mapsize][$e._Myoff % ((std::deque<$T1,$T2 > *)$e._Mycont)->_EEN_DS]
				)
			)
		)
	)
	children
	(
		#if( $e._EEN_HID == 0 )
		(
			#if( ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Myoff + ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Mysize > $e._Myoff)
			(
				#(
					ptr: ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Map[ ($e._Myoff / ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_EEN_DS) % ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_Mapsize][$e._Myoff % ((std::deque<$T1,$T2 > *)($e._Myaux->_Mycontainer))->_EEN_DS]
				)
			)
		)
		#else
		(
			#if( ((std::deque<$T1,$T2 > *)$e._Mycont)->_Myoff + ((std::deque<$T1,$T2 > *)$e._Mycont)->_Mysize > $e._Myoff)
			(
				#(
					ptr: ((std::deque<$T1,$T2 > *)$e._Mycont)->_Map[ ($e._Myoff / ((std::deque<$T1,$T2 > *)$e._Mycont)->_EEN_DS) % ((std::deque<$T1,$T2 > *)$e._Mycont)->_Mapsize][$e._Myoff % ((std::deque<$T1,$T2 > *)$e._Mycont)->_EEN_DS]
				)
			)
		)
	)
}
;------------------------------------------------------------------------------
;  std::queue
;------------------------------------------------------------------------------
std::queue<*>{
	children
	(
		#array
		(
			expr : $e.c._Map[ (($i + $e.c._Myoff) / $e.c._EEN_DS) % $e.c._Mapsize][($i + $e.c._Myoff) % $e.c._EEN_DS],
			size : $e.c._Mysize
		)
	)
	preview
	(
		#(
			"[", $e.c._Mysize, "](",
			#array
			(
				expr : $e.c._Map[ (($i + $e.c._Myoff) / $e.c._EEN_DS) % $e.c._Mapsize][($i + $e.c._Myoff) % $e.c._EEN_DS],
				size : $e.c._Mysize
			),
			")"
		)
	)
}
;------------------------------------------------------------------------------
;  std::priority_queue
;------------------------------------------------------------------------------
std::priority_queue<*>{
	preview ( $e.c)
}
;------------------------------------------------------------------------------
;  std::set
;------------------------------------------------------------------------------
std::set<*>{
	preview
	(
		#(
			"[", $e._Mysize , "](",
			#tree
			(
				head : $e._Myhead->_Parent,
				skip : $e._Myhead,
				left : _Left,
				right : _Right,
				size  : $e._Mysize
			) : $e._Myval,
			")"
		)
	)
	children
	(
		#tree
		(
			head : $e._Myhead->_Parent,
			skip : $e._Myhead,
			left : _Left,
			right : _Right,
			size  : $e._Mysize
		) : $e._Myval
	)
}
;------------------------------------------------------------------------------
;  std::multi_set
;------------------------------------------------------------------------------
std::multiset<*>{
	preview
	(
		#(
			"[", $e._Mysize , "](",
			#tree
			(
				head : $e._Myhead->_Parent,
				skip : $e._Myhead,
				left : _Left,
				right : _Right,
				size  : $e._Mysize
			) : $e._Myval,
			")"
		)
	)
	children
	(
		#tree
		(
			head : $e._Myhead->_Parent,
			skip : $e._Myhead,
			left : _Left,
			right : _Right,
			size  : $e._Mysize
		) : $e._Myval
	)
}
;------------------------------------------------------------------------------
;  std::_Tree (shared my map/multimap/set/multiset)
;------------------------------------------------------------------------------
std::_Tree<*>::iterator|std::_Tree<*>::const_iterator{
	preview		( #($e._Ptr->_Myval))
	children	( #(ptr: $e._Ptr->_Myval))
}
;------------------------------------------------------------------------------
;  std::stack
;------------------------------------------------------------------------------
std::stack<*>{
	children
	(
		#array
		(
			expr : $e.c._Map[ (($i + $e.c._Myoff) / $e.c._EEN_DS) % $e.c._Mapsize][($i + $e.c._Myoff) % $e.c._EEN_DS],
			size : $e.c._Mysize
			)
	)
	preview
	(
		#(
			"[", $e.c._Mysize , "](",
			#array
			(
				expr : $e.c._Map[ (($i + $e.c._Myoff) / $e.c._EEN_DS) % $e.c._Mapsize][($i + $e.c._Myoff) % $e.c._EEN_DS],
				size : $e.c._Mysize
			),
			")"
		)
	)
}
;------------------------------------------------------------------------------
;  stdext::hash_map
;  stdext::hash_multimap
;  stdext::hash_set
;  stdext::hash_multiset
;  std::tr1::unordered_set
;  std::tr1::unordered_multiset
;  std::tr1::unordered_map
;  std::tr1::unordered_multimap
;------------------------------------------------------------------------------
stdext::hash_map<*>|stdext::hash_multimap<*>|stdext::hash_set<*>|stdext::hash_multiset<*>|std::tr1::unordered_set<*>|std::tr1::unordered_multiset<*>|std::tr1::unordered_map<*>|std::tr1::unordered_multimap<*>{
	preview
	(
		#(
			"[", $e._List._Mysize, "](",
			#list
			(
				head : $e._List._Myhead->_Next,
				size : $e._List._Mysize,
				next : _Next
			) : $e._Myval,
			")"
		)
	)
	children
	(
		#list
		(
			head : $e._List._Myhead->_Next,
			size : $e._List._Mysize,
			next : _Next
		) : $e._Myval
	)
}
;------------------------------------------------------------------------------
;  std::complex
;------------------------------------------------------------------------------
std::complex<*>{
	children
	(
		#(
			real: $e._Val[0],
			imaginary: $e._Val[1]
		)
	)
	preview
	(
		#if($e._Val[1] != 0)
		(
			#if ($e._Val[0] != 0)
			(	; Real and Imaginary components
				#if ($e._Val[1] >= 0)
					( #($e._Val[0],"+i*", $e._Val[1]))
				#else
					( #($e._Val[0],"-i*", -$e._Val[1]))
			)
			#else
			(	; Purely imaginary
				#if ($e._Val[1] >= 0.0)
				( #("i*", $e._Val[1]))
				#else
				( #("-i*", -$e._Val[1]))
			)
		)
		#else
		(		; Purely real
			$e._Val[0]
		)
	)
}
;------------------------------------------------------------------------------
;  std::valarray
;------------------------------------------------------------------------------
std::valarray<*>{
	preview
	(
		#(
			"[", $e._Mysize , "](",
			#array
			(
				expr :	($e._Myptr)[$i],
				size :	$e._Mysize
			),
			")"
		)
	)
	children
	(
		#array
		(
			expr :	($e._Myptr)[$i],
			size :	$e._Mysize
		)
	)
}
;------------------------------------------------------------------------------
;  PROPVARIANT
;------------------------------------------------------------------------------
; Visualizers for VT_VECTOR C arrays
tagCAC|tagCAUB|tagCAI|tagCAUI|tagCAL|tagCAUL|tagCAFLT|tagCADBL|tagCACY|tagCADATE|tagCABSTR|tagCABSTRBLOB|tagCABOOL|tagCASCODE|tagCAPROPVARIANT|tagCAH|tagCAUH|tagCALPSTR|tagCALPWSTR|tagCAFILETIME|tagCACLIPDATA|tagCACLSID{
	preview(
		#(
			"[", $e.cElems , "](",
			#array
			(
				expr :	($e.pElems)[$i],
				size :	$e.cElems
			),
			")"
		)
	)
	children
	(
		#array
		(
			expr :	($e.pElems)[$i],
			size :	$e.cElems
		)
	)
}
; Visualizers for SAFE ARRAY
tagSAFEARRAY|SAFEARRAY{
	preview(
		#if ($e.fFeatures & 0x0080)		; FADF_HAVEVARTYPE
		(
			; Switch on the variant type field - which is stored 4 bytes
			; before the beginning of the SAFEARRAY type
			#switch( ((unsigned *)&($e))[-1] )
			#case 0x2		; VT_I2 | VT_ARRAY
			(
				#(
					"safearray of I2 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((signed short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x3		; VT_I4 | VT_ARRAY
			(
				#(
					"safearray of I4 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((signed int *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x4		; VT_R4 | VT_ARRAY
			(
				#(
					"safearray of R4 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((float *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x5		; VT_R8 | VT_ARRAY
			(
				#(
					"safearray of R8 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((double *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				 )
			)
			#case 0x6		; VT_CY | VT_ARRAY
			(
				#(
					"safearray of CY = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((CY *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x7		; VT_DATE | VT_ARRAY
			(
				#(
					"safearray of DATE = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((DATE *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x8		; VT_BSTR | VT_ARRAY
			(
				#(
					"safearray of BSTR = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((wchar_t **)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0xa		; VT_ERROR | VT_ARRAY
			(
				#(
					"safearray of ERROR = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((long *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0xb		; VT_BOOL | VT_ARRAY
			(
				#(
					"safearray of BOOL = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0xc		; VT_VARIANT | VT_ARRAY
			(
				#(
					"safearray of VARIANT = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((tagVARIANT *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x10		; VT_I1 | VT_ARRAY
			(
				#(
					"safearray of I1 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((signed char *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x11		; VT_UI1 | VT_ARRAY
			(
				#(
					"safearray of UI1 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((unsigned char *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x12		; VT_UI2 | VT_ARRAY
			(
				#(
					"safearray of UI2 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((unsigned short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					  ),
				")"
				)
			)
			#case 0x13		; VT_UI4 | VT_ARRAY
			(
				#(
					"safearray of UI4 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((unsigned int *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x14		; VT_I8 | VT_ARRAY
			(
				#(
					"safearray of I8 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((signed __int64 *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x15		; VT_UI8 | VT_ARRAY
			(
				#(
					"safearray of UI8 = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((unsigned __int64 *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x16		; VT_INT | VT_ARRAY
			(
				#(
					"safearray of INT = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((int *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x17		; VT_UINT | VT_ARRAY
			(
				#(
					"safearray of UINT = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((unsigned *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x1e		; VT_LPSTR | VT_ARRAY
			(
				#(
					"safearray of LPSTR = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((char **)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x1f		; VT_LPWSTR | VT_ARRAY
			(
				#(
					"safearray of LPWSTR = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((wchar_t **)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x40		; VT_FILETIME | VT_ARRAY
			(
				#(
					"safearray of FILETIME = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((FILETIME *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x47		; VT_CLIPDATA | VT_ARRAY
			(
				#(
					"safearray of CLIPDATA = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((CLIPDATA *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
			#case 0x48		; VT_CLSID | VT_ARRAY
			(
				#(
					"safearray of CLSID = [",
					; output the rank array
					#array( expr: $e.rgsabound[$i].cElements, size: $e.cDims),
					"](",
					; output the data elements
					#array(
						expr: ((CLSID *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					),
					")"
				)
			)
		)
		#elif ($e.fFeatures & 0x0100)	; FADF_BSTR
		(
			#("safearray of BSTR = ",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims) : #("[",$e,"]"), "(", #array(expr: ((wchar_t * *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), ")")
		)
		#elif ($e.fFeatures & 0x0200)	; FADF_UNKNOWN
		(
				#("safearray of IUnknown* = ",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims) : #("[",$e,"]"), "(", #array(expr: ((IUnknown *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), ")")
		)
		#elif ($e.fFeatures & 0x0400)	; FADF_DISPATCH
		(
				#("safearray of IDispatch* = ",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims) : #("[",$e,"]"), "(", #array(expr: ((IDispatch*)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), ")")
		)
		#elif ($e.fFeatures & 0x0800)	; FADF_VARIANT
		(
				#("safearray of VARIANT = ",#array(expr: $e.rgsabound[$i].cElements, size: $e.cDims) : #("[",$e,"]"), "(", #array(expr: ((tagVARIANT *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound ), ")")
		)
	)
	children
	(
		#(		;[actual members]: [$e,!],
			#if ($e.fFeatures & 0x0080)		; FADF_HAVEVARTYPE
			(
				#switch( ((unsigned *)&($e))[-1] )		; for some reason the VT field is before the SAFEARRAY struct
				#case 2 ; VT_I2|VT_ARRAY
				(
					#array(
						expr: ((signed short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 3 ; VT_I4|VT_ARRAY
				(
					#array(
						expr: ((signed int	 *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 4 ; VT_R4|VT_ARRAY
				(
					#array(
						expr: ((float *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 5 ; VT_R8|VT_ARRAY
				(
					#array(
						expr: ((double	*)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x10		; VT_I1|VT_ARRAY
				(
					#array(
						expr: ((signed char *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x11		; VT_UI1|VT_ARRAY
				(
					#array(
						expr: ((unsigned char *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x12		; VT_UI2|VT_ARRAY
				(
					#array(
						expr: ((unsigned short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x13		; VT_UI4|VT_ARRAY
				(
					#array(
						expr: ((unsigned int *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x14		; VT_I8|VT_ARRAY
				(
					#array(
						expr: ((signed __int64 *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x15		; VT_UI8|VT_ARRAY
				(
					#array(
						expr: ((unsigned __int64 *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x1e		; VT_LPSTR|VT_ARRAY
				(
					#array(
						expr: ((char * *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x1f		; VT_LPWSTR|VT_ARRAY
				(
					#array(
						expr: ((wchar_t **)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0xc		; VT_VARIANT|VT_ARRAY
				(
					#array(
						expr: ((tagVARIANT *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0xb		; VT_BOOL|VT_ARRAY
				(
					#array(
						expr: ((short *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0xa		; VT_ERROR|VT_ARRAY
				(
					#array(
						expr: ((long *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 6 ; VT_CY|VT_ARRAY
				(
					#array(
						expr: ((CY *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 7 ; VT_DATE|VT_ARRAY
				(
					#array(
						expr: ((DATE *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x40		; VT_FILETIME|VT_ARRAY
				(
					#array(
						expr: ((FILETIME *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x48		; VT_CLSID|VT_ARRAY
				(
					#array(
						expr: ((CLSID *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x47		; VT_CF|VT_ARRAY
				(
					#array(
						expr: ((CLIPDATA *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 8 ; VT_BSTR|VT_ARRAY
				(
					#array(
						expr: ((wchar_t * *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x16		; VT_INT|VT_ARRAY
				(
					#array(
						expr: ((int *)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#case 0x17		; VT_UINT|VT_ARRAY
				(
					#array(
						expr: ((unsigned int*)$e.pvData)[$i],
						size: $e.rgsabound[$r].cElements,
						rank: $e.cDims,
						base: $e.rgsabound[$r].lLbound
					)
				)
				#default
				(
						#([actual members]: [$e,!])
				)
				#except
				(
						#([actual members]: [$e,!])
				)
			)
			#elif ($e.fFeatures & 0x0100)	; FADF_BSTR
			(
					#array(expr: ((wchar_t * *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )
			)
			#elif ($e.fFeatures & 0x0200)	; FADF_UNKNOWN
			(
					#array(expr: ((IUnknown *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )
			)
			#elif ($e.fFeatures & 0x0400)	; FADF_DISPATCH
			(
					#array(expr: ((IDispatch *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )
			)
			#elif ($e.fFeatures & 0x0800)	; FADF_VARIANT
			(
					#array(expr: ((tagVARIANT *)$e.pvData)[$i], size: $e.rgsabound[$r].cElements, rank: $e.cDims, base: $e.rgsabound[$r].lLbound )
			)
		)
	)
}
tagPROPVARIANT|tagVARIANT|PROPVARIANT|VARIANT{
	preview(
		#switch ($e.vt)
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;		Base Types		;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		#case 0 ( #("Empty") )	; VT_EMPTY
		#case 1 ( #("NULL") )	; VT_NULL
		#case 2 ( #("I2 = ", $e.iVal) ) ; VT_I2
		#case 3 ( #("I4 = ", $e.lVal) ) ; VT_I4
		#case 4 ( #("R4 = ", $e.fltVal) )		; VT_R4
		#case 5 ( #("R8 = ", $e.dblVal) )		; VT_R8
		#case 6 ( #("CY = ", $e.cyVal) )		; VT_CY
		#case 7 ( #("DATE =  ", $e.date) )		; VT_DATE
		#case 8 ( #("BSTR = ", $e.bstrVal) )	; VT_BSTR
		#case 9 ( #("DISPATCH =  ", $e.pdispVal) )		; VT_DISPATCH
		#case 10 ( #("ERROR =  ", $e.scode) )	; VT_ERROR
		#case 0xB ( #("BOOL =  ", $e.boolVal) ) ; VT_BOOL
		#case 0xC ( #("VARIANT ") )		; VT_VARIANT
		#case 0xD ( #("UNKNOWN =  ", $e.punkVal) )		; VT_UNKOWN
		#case 0xE ( #("DECIMAL = ", $e.decVal) )		; VT_DECIMAL
		#case 0x10 ( #("I1 =  ", $e.cVal) )		; VT_I1
		#case 0x11 ( #("UI1 =  ", $e.bVal) )	; VT_UI1
		#case 0x12 ( #("UI2 =  ", $e.uiVal) )	; VT_UI2
		#case 0x13 ( #("UI4 =  ", $e.ulVal) )	; VT_UI4
		#case 0x14 ( #("I8 =  ", *(__int64*)&$e.dblVal) )	; VT_I8
		#case 0x15 ( #("UI8 =  ", *(unsigned __int64*)&$e.dblVal) )	; VT_UI8
		#case 0x16 ( #("INT =  ", $e.intVal) )	; VT_INT
		#case 0x17 ( #("UINT = ", $e.uintVal) ) ; VT_UINT
		#case 0x18 ( #("VOID ") )		; VT_VOID
		#case 0x19 ( #("HRESULT ") )	; VT_HRESULT
		#case 0x1A ( #("PTR ") )		; VT_PTR
		#case 0x1B ( #("SAFEARRAY ") )	; VT_SAFEARRAY
		#case 0x1C ( #("CARRAY ") )		; VT_CARRAY
		#case 0x1D ( #("USERDEFINED ") )		; VT_USERDEFINED
		#case 0x1E ( #("LPSTR =  ", $e.pszVal) )		; VT_LPSTR
		#case 0x1F ( #("LPWSTR =  ", $e.pwszVal) )		; VT_LPWSTR
		#case 0x24 ( #("RECORD	") )	; VT_RECORD
		#case 0x26 ( #("UINT_PTR ") )	; VT_UINT_PTR
		#case 0x40 ( #("FILETIME =	", $e.filetime) )	; VT_FILETIME
		#case 0x42 ( #("STREAM =  ", $e.pStream) )		; VT_STREAM
		#case 0x43 ( #("STORAGE = ", $e.pStorage) )		; VT_STORAGE
		#case 0x44 ( #("STREAMED_OBJECT =  ", $e.pStream) )		; VT_STREAMED_OBJECT
		#case 0x45 ( #("STORED_OBJECT =  ", $e.pStorage) )		; VT_STORED_OBJECT
		#case 0x46 ( #("BLOB_OBJECT = ", $e.blob ) )	; VT_BLOB_OBJECT
		#case 0x47 ( #("CF =  ", $e.pclipdata) )		; VT_CF
		#case 0x48 ( #("CLSID = ", $e.puuid) )	; VT_CLSID
		#case 0x49 ( #("VERSIONED_STREAM = ", $e.pVersionedStream) )	; VT_VERSIONED_STREAM
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;	 Vector types		;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		#case 0x1002 ( #("vector of I2 = ", $e.cai) )	; VT_I2|VT_VECTOR
		#case 0x1003 ( #("vector of I4 = ", $e.cal) )	; VT_I4|VT_VECTOR
		#case 0x1004 ( #("vector of R4 = ", $e.caflt) ) ; VT_R4|VT_VECTOR
		#case 0x1005 ( #("vector of R8 = ", $e.cadbl) ) ; VT_R8|VT_VECTOR
		#case 0x1010 ( #("vector of I1 =  ", $e.cac) )	; VT_I1|VT_VECTOR
		#case 0x1011 ( #("vector of UI1 =  ", $e.caub) )		; VT_UI1|VT_VECTOR
		#case 0x1012 ( #("vector of UI2 =  ", $e.caui) )		; VT_UI2|VT_VECTOR
		#case 0x1013 ( #("vector of UI4 =  ", $e.caul) )		; VT_UI4|VT_VECTOR
		#case 0x1014 ( #("vector of I8 =  ", $e.cah) )	; VT_I8|VT_VECTOR
		#case 0x1015 ( #("vector of UI8 =  ", $e.cauh) )		; VT_UI8|VT_VECTOR
		#case 0x101E ( #("vector of LPSTR =  ", $e.calpstr) )	; VT_LPSTR|VT_VECTOR
		#case 0x101F ( #("vector of LPWSTR =  ", $e.calpwstr) ) ; VT_LPWSTR|VT_VECTOR
		#case 0x100C ( #("vector of VARIANT ", $e.capropvar) )	; VT_VARIANT|VT_VECTOR
		#case 0x100B ( #("vector of BOOL =	", $e.cabool) )		; VT_BOOL|VT_VECTOR
		#case 0x100A ( #("vector of ERROR =  ", $e.cascode) )	; VT_ERROR|VT_VECTOR
		#case 0x1006 ( #("vector of CY = ", $e.cacy) )	; VT_CY|VT_VECTOR
		#case 0x1007 ( #("vector of DATE =	", $e.cadate) )		; VT_DATE|VT_VECTOR
		#case 0x1040 ( #("vector of FILETIME =	", $e.cafiletime) )		; VT_FILETIME|VT_VECTOR
		#case 0x1048 ( #("vector of CLSID = ", $e.cauuid) )		; VT_CLSID|VT_VECTOR
		#case 0x1047 ( #("vector of CF =  ", $e.caclipdata) )	; VT_CF|VT_VECTOR
		#case 0x1008 ( #("vector of BSTR = ", $e.cabstr) )		; VT_BSTR|VT_VECTOR
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		;;	 Byref Types		;;
		;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
		#case 0x4016 ( #("byref of INT =  ", $e.pintVal) )		; VT_INT|VT_BYREF
		#case 0x4017 ( #("byref of UINT = ", $e.puintVal) )		; VT_UINT|VT_BYREF
		#case 0x4002 ( #("byref of I2 = ", $e.piVal) )	; VT_I2|VT_BYREF
		#case 0x4003 ( #("byref of I4 = ", $e.plVal) )	; VT_I4|VT_BYREF
		#case 0x4004 ( #("byref of R4 = ", $e.pfltVal) )		; VT_R4|VT_BYREF
		#case 0x4005 ( #("byref of R8 = ", $e.pdblVal) )		; VT_R8|VT_BYREF
		#case 0x4010 ( #("byref of I1 =  ", $e.pcVal) ) ; VT_I1|VT_BYREF
		#case 0x4011 ( #("byref of UI1 =  ", $e.pbVal) )		; VT_UI1|VT_BYREF
		#case 0x4012 ( #("byref of UI2 =  ", $e.puiVal) )		; VT_UI2|VT_BYREF
		#case 0x4013 ( #("byref of UI4 =  ", $e.pulVal) )		; VT_UI4|VT_BYREF
		#case 0x4014 ( #("byref of I8 =  ", (__int64*)$e.pdblVal) )		; VT_I8|VT_BYREF
		#case 0x4015 ( #("byref of UI8 =  ", (unsigned __int64*)$e.pudblVal) )		; VT_UI8|VT_BYREF
		#case 0x400C ( #("byref of VARIANT ", $e.pvarVal) )		; VT_VARIANT|VT_BYREF
		#case 0x400B ( #("byref of BOOL =  ", $e.pboolVal) )	; VT_BOOL|VT_BYREF
		#case 0x400A ( #("byref of ERROR =	", $e.pscode) )		; VT_ERROR|VT_BYREF
		#case 0x4006 ( #("byref of CY = ", $e.pcyVal) ) ; VT_CY|VT_BYREF
		#case 0x4007 ( #("byref of DATE =  ", $e.pdate) )		; VT_DATE|VT_BYREF
		#case 0x4008 ( #("byref of BSTR = ", $e.pbstrVal) )		; VT_BSTR|VT_BYREF
		#case 0x400E ( #("byref of DECIMAL = ", $e.pdecVal) )	; VT_DECIMAL|VT_BYREF
		#case 0x400D ( #("byref of UNKNOWN =  ", $e.ppunkVal) ) ; VT_UNKOWN|VT_BYREF
		#case 0x4009 ( #("byref of DISPATCH =  ", $e.ppdispVal) )		; VT_DISPATCH|VT_BYREF
		#case 0x6000 ( #("byref of ARRAY =	", $e.pparray) )	; VT_ARRAY|VT_BYREF
		#default
		(
			#if ($e.vt & 0x2000) ( $e.parray)
			#else ( #("Unknown vt type = ", $e.vt))
		)
	)
	children(
		#(
			vt: $e.vt,
			#switch ($e.vt)
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			;;		Base Types		;;
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			#case 0x2 ( #(I2  : $e.iVal) )	; VT_I2
			#case 0x3 ( #(I4  : $e.lVal) )	; VT_I4
			#case 0x4 ( #(R4  : $e.fltVal) )		; VT_R4
			#case 0x5 ( #(R8  : $e.dblVal) )		; VT_R8
			#case 0x6 ( #(CY  : $e.cyVal) ) ; VT_CY
			#case 0x7 ( #(DATE	 : $e.date) )		; VT_DATE
			#case 0x8 ( #(BSTR	: $e.bstrVal) )		; VT_BSTR
			#case 0x9 ( #(DISPATCH	 : $e.pdispVal) )		; VT_DISPATCH
			#case 0xA ( #(ERROR   : $e.scode) )		; VT_ERROR
			#case 0xB ( #(BOOL	 : $e.boolVal) )	; VT_BOOL
			#case 0xD ( #(UNKNOWN	: $e.punkVal) ) ; VT_UNKOWN
			#case 0xE ( #(DECIMAL  : $e.decVal) )	; VT_DECIMAL
			#case 0x10 ( #(I1	: $e.cVal) )		; VT_I1
			#case 0x11 ( #(UI1	 : $e.bVal) )		; VT_UI1
			#case 0x12 ( #(UI2	 : $e.uiVal) )		; VT_UI2
			#case 0x13 ( #(UI4	 : $e.ulVal) )		; VT_UI4
			#case 0x14 ( #(I8	: *(__int64*)&$e.dblVal) )		; VT_I8
			#case 0x15 ( #(UI8	 : *(unsigned __int64*)&$e.dblVal) )		; VT_UI8
			#case 0x16 ( #(INT	 : $e.intVal) )		; VT_INT
			#case 0x17 ( #(UINT  : $e.uintVal) )	; VT_UINT
			#case 0x1E ( #(LPSTR   : $e.pszVal) )	; VT_LPSTR
			#case 0x1F ( #(LPWSTR	: $e.pwszVal) ) ; VT_LPWSTR
			#case 0x40 ( #(FILETIME   : $e.filetime) )		; VT_FILETIME
			#case 0x42 ( #(STREAM	: $e.pStream) ) ; VT_STREAM
			#case 0x43 ( #(STORAGE	: $e.pStorage) )		; VT_STORAGE
			#case 0x44 ( #(STREAMED_OBJECT	 : $e.pStream) )		; VT_STREAMED_OBJECT
			#case 0x45 ( #(STORED_OBJECT   : $e.pStorage) ) ; VT_STORED_OBJECT
			#case 0x46 ( #(BLOB_OBJECT	: $e.blob ) )		; VT_BLOB_OBJECT
			#case 0x47 ( #(CF	: $e.pclipdata) )	; VT_CF
			#case 0x48 ( #(CLSID  : $e.puuid) )		; VT_CLSID
			#case 0x49 ( #(VERSIONED_STREAM  : $e.pVersionedStream) )		; VT_VERSIONED_STREAM
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			;;	 Vector types		;;
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			#case 0x1002 ( #(vector of I2  : $e.cai) )		; VT_I2|VT_VECTOR
			#case 0x1003 ( #(vector of I4  : $e.cal) )		; VT_I4|VT_VECTOR
			#case 0x1004 ( #(vector of R4  : $e.caflt) )	; VT_R4|VT_VECTOR
			#case 0x1005 ( #(vector of R8  : $e.cadbl) )	; VT_R8|VT_VECTOR
			#case 0x1010 ( #(vector of I1	: $e.cac) )		; VT_I1|VT_VECTOR
			#case 0x1011 ( #(vector of UI1	 : $e.caub) )	; VT_UI1|VT_VECTOR
			#case 0x1012 ( #(vector of UI2	 : $e.caui) )	; VT_UI2|VT_VECTOR
			#case 0x1013 ( #(vector of UI4	 : $e.caul) )	; VT_UI4|VT_VECTOR
			#case 0x1014 ( #(vector of I8	: $e.cah) )		; VT_I8|VT_VECTOR
			#case 0x1015 ( #(vector of UI8	 : $e.cauh) )	; VT_UI8|VT_VECTOR
			#case 0x101E ( #(vector of LPSTR   : $e.calpstr) )		; VT_LPSTR|VT_VECTOR
			#case 0x101F ( #(vector of LPWSTR	: $e.calpwstr) )	; VT_LPWSTR|VT_VECTOR
			#case 0x100C ( #(vector of VARIANT : $e.capropvar) )	; VT_VARIANT|VT_VECTOR
			#case 0x100B ( #(vector of BOOL   : $e.cabool) )		; VT_BOOL|VT_VECTOR
			#case 0x100A ( #(vector of ERROR   : $e.cascode) )		; VT_ERROR|VT_VECTOR
			#case 0x1006 ( #(vector of CY  : $e.cacy) )		; VT_CY|VT_VECTOR
			#case 0x1007 ( #(vector of DATE   : $e.cadate) )		; VT_DATE|VT_VECTOR
			#case 0x1040 ( #(vector of FILETIME   : $e.cafiletime) )		; VT_FILETIME|VT_VECTOR
			#case 0x1048 ( #(vector of CLSID  : $e.cauuid) )		; VT_CLSID|VT_VECTOR
			#case 0x1047 ( #(vector of CF	: $e.caclipdata) )		; VT_CF|VT_VECTOR
			#case 0x1008 ( #(vector of BSTR  : $e.cabstr) ) ; VT_BSTR|VT_VECTOR
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			;;	 Byref Types		;;
			;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
			#case 0x4016 ( #(byref of INT	: $e.pintVal) ) ; VT_INT|VT_BYREF
			#case 0x4017 ( #(byref of UINT	: $e.puintVal) )		; VT_UINT|VT_BYREF
			#case 0x4002 ( #(byref of I2  : $e.piVal) )		; VT_I2|VT_BYREF
			#case 0x4003 ( #(byref of I4  : $e.plVal) )		; VT_I4|VT_BYREF
			#case 0x4004 ( #(byref of R4  : $e.pfltVal) )	; VT_R4|VT_BYREF
			#case 0x4005 ( #(byref of R8  : $e.pdblVal) )	; VT_R8|VT_BYREF
			#case 0x4010 ( #(byref of I1   : $e.pcVal) )	; VT_I1|VT_BYREF
			#case 0x4011 ( #(byref of UI1	: $e.pbVal) )	; VT_UI1|VT_BYREF
			#case 0x4012 ( #(byref of UI2	: $e.puiVal) )	; VT_UI2|VT_BYREF
			#case 0x4013 ( #(byref of UI4	: $e.pulVal) )	; VT_UI4|VT_BYREF
			#case 0x4014 ( #(byref of I8	: (__int64*)$e.pdblVal) )	; VT_I8|VT_BYREF
			#case 0x4015 ( #(byref of UI8	: (unsigned __int64*)$e.pdblVal) ) ; VT_UI8|VT_BYREF
			#case 0x400C ( #(byref of VARIANT : $e.pvarVal) )		; VT_VARIANT|VT_BYREF
			#case 0x400B ( #(byref of BOOL	 : $e.pboolVal) )		; VT_BOOL|VT_BYREF
			#case 0x400A ( #(byref of ERROR   : $e.pscode) )		; VT_ERROR|VT_BYREF
			#case 0x4006 ( #(byref of CY  : $e.pcyVal) )	; VT_CY|VT_BYREF
			#case 0x4007 ( #(byref of DATE	 : $e.pdate) )	; VT_DATE|VT_BYREF
			#case 0x4008 ( #(byref of BSTR	: $e.pbstrVal) )		; VT_BSTR|VT_BYREF
			#case 0x400E ( #(byref of DECIMAL  : $e.pdecVal) )		; VT_DECIMAL|VT_BYREF
			#case 0x400D ( #(byref of UNKNOWN	: $e.ppunkVal) )	; VT_UNKOWN|VT_BYREF
			#case 0x4009 ( #(byref of DISPATCH	 : $e.ppdispVal) )	; VT_DISPATCH|VT_BYREF
			#case 0x6000 ( #(byref of ARRAY   : $e.pparray) )		; VT_ARRAY|VT_BYREF

			; the following are either empty or invalid vt values for a variant
			; #case 0 ( #(Empty :) )		; VT_EMPTY
			; #case 0x1 ( #(NULL :) )		; VT_NULL
			; #case 0xC ( #(VARIANT :) )	; VT_VARIANT
			; #case 0x18 ( #(VOID :) )		; VT_VOID
			; #case 0x19 ( #(HRESULT :) )	; VT_HRESULT
			; #case 0x1A ( #(PTR :) )		; VT_PTR
			; #case 0x1B ( #(SAFEARRAY :) ) ; VT_SAFEARRAY
			; #case 0x1C ( #(CARRAY :) )	; VT_CARRAY
			; #case 0x1D ( #(USERDEFINED :) )		; VT_USERDEFINED
			; #case 0x24 ( #(RECORD  :) )	; VT_RECORD
			; #case 0x26 ( #(UINT_PTR :) )	; VT_UINT_PTR
			#default
			(
				#if ($e.vt & 0x2000 )
					( #(safearray: $e.parray))
				#else
				(
					#(
						[raw members]: [$e,!]	; unformatted data members
					 )
				 )
			)
			#except
			(
				#(
					[raw members]: [$e,!]	; unformatted data members
				 )
			)
		)
	)
}






utils::Variant{
	preview
	(
		#if($e._et == 0)
		(
			#("Null")
		)
		#elif($e._et == 1)
		(
			#("String, ", *(std::basic_string<char,std::char_traits<char>,std::allocator<char> > *)$e._dbgData)
		)
		#elif($e._et == 2)
		(
			#("Float, ", *(float *)$e._dbgData)
		)
		#elif($e._et == 3)
		(
			#("Double, ", *(double *)$e._dbgData)
		)
		#elif($e._et == 4)
		(
			#("Int8, ", 
				#if(1 == sizeof(char))
				(
					*(signed char *)$e._dbgData
				)
				#elif(1 == sizeof(short))
				(
					*(signed short *)$e._dbgData
				)
				#elif(1 == sizeof(int))
				(
					*(signed int *)$e._dbgData
				)
				#elif(1 == sizeof(long))
				(
					*(signed long *)$e._dbgData
				)
				#else
				(
					"what type in 1 byte?"
				)
			)
		)
		#elif($e._et == 5)
		(
			#("Int16, ", 
				#if(2 == sizeof(char))
				(
					*(signed char *)$e._dbgData
				)
				#elif(2 == sizeof(short))
				(
					*(signed short *)$e._dbgData
				)
				#elif(2 == sizeof(int))
				(
					*(signed int *)$e._dbgData
				)
				#elif(2 == sizeof(long))
				(
					*(signed long *)$e._dbgData
				)
				#else
				(
					"what type in 2 bytes?"
				)
			)
		)
		#elif($e._et == 6)
		(
			#("Int32, ", 
				#if(4 == sizeof(char))
				(
					*(signed char *)$e._dbgData
				)
				#elif(4 == sizeof(short))
				(
					*(signed short *)$e._dbgData
				)
				#elif(4 == sizeof(int))
				(
					*(signed int *)$e._dbgData
				)
				#elif(4 == sizeof(long))
				(
					*(signed long *)$e._dbgData
				)
				#else
				(
					"what type in 4 bytes?"
				)
			)
		)
		#elif($e._et == 7)
		(
			#("Int64, ", 
				#if(8 == sizeof(char))
				(
					*(signed char *)$e._dbgData
				)
				#elif(8 == sizeof(short))
				(
					*(signed short *)$e._dbgData
				)
				#elif(8 == sizeof(int))
				(
					*(signed int *)$e._dbgData
				)
				#elif(8 == sizeof(long))
				(
					*(signed long *)$e._dbgData
				)
				#elif(8 == sizeof(__int64))
				(
					*(signed __int64*)$e._dbgData
				)
				#else
				(
					"what type in 8 bytes?"
				)
			)
		)
		#elif($e._et == 8)
		(
			#("UInt8, ", 
				#if(1 == sizeof(char))
				(
					*(unsigned char *)$e._dbgData
				)
				#elif(1 == sizeof(short))
				(
					*(unsigned short *)$e._dbgData
				)
				#elif(1 == sizeof(int))
				(
					*(unsigned int *)$e._dbgData
				)
				#elif(1 == sizeof(long))
				(
					*(unsigned long *)$e._dbgData
				)
				#else
				(
					"what type in 1 byte?"
				)
			)
		)
		#elif($e._et == 9)
		(
			#("UInt16, ", 
				#if(2 == sizeof(char))
				(
					*(unsigned char *)$e._dbgData
				)
				#elif(2 == sizeof(short))
				(
					*(unsigned short *)$e._dbgData
				)
				#elif(2 == sizeof(int))
				(
					*(unsigned int *)$e._dbgData
				)
				#elif(2 == sizeof(long))
				(
					*(unsigned long *)$e._dbgData
				)
				#else
				(
					"what type in 2 bytes?"
				)
			)
		)
		#elif($e._et == 10)
		(
			#("UInt32, ", 
				#if(4 == sizeof(char))
				(
					*(unsigned char *)$e._dbgData
				)
				#elif(4 == sizeof(short))
				(
					*(unsigned short *)$e._dbgData
				)
				#elif(4 == sizeof(int))
				(
					*(unsigned int *)$e._dbgData
				)
				#elif(4 == sizeof(long))
				(
					*(unsigned long *)$e._dbgData
				)
				#else
				(
					"what type in 4 bytes?"
				)
			)
		)
		#elif($e._et == 11)
		(
			#("UInt64, ", 
				#if(8 == sizeof(char))
				(
					*(unsigned char *)$e._dbgData
				)
				#elif(8 == sizeof(short))
				(
					*(unsigned short *)$e._dbgData
				)
				#elif(8 == sizeof(int))
				(
					*(unsigned int *)$e._dbgData
				)
				#elif(8 == sizeof(long))
				(
					*(unsigned long *)$e._dbgData
				)
				#elif(8 == sizeof(__int64))
				(
					*(unsigned __int64*)$e._dbgData
				)
				#else
				(
					"what type in 8 bytes?"
				)
			)
		)
		#elif($e._et == 12)
		(
			#("VectorChar, ", *(std::vector<char,std::allocator<char> > *)$e._dbgData)
		)
		#elif($e._et == 13)
		(
			#("Date, ", *(boost::gregorian::date *)$e._dbgData)
		)
		#elif($e._et == 14)
		(
			#("Time, ", *(boost::posix_time::ptime *)$e._dbgData)
		)
		#elif($e._et == 15)
		(
			#("VectorVariant, ", *(std::vector<utils::Variant,std::allocator<utils::Variant> > *)$e._dbgData)
		)
		#elif($e._et == 16)
		(
			#("MapStringVariant=")
		)
		#elif($e._et == 17)
		(
			#("Bool=")
		)
		#elif($e._et == 18)
		(
			#("Tm=")
		)
		#elif($e._et == 19)
		(
			#("Bitset8=")
		)
		#elif($e._et == 20)
		(
			#("Bitset16=")
		)
		#elif($e._et == 21)
		(
			#("Bitset32=")
		)
		#elif($e._et == 22)
		(
			#("Bitset64=")
		)
		#elif($e._et == 23)
		(
			#("Bitset128=")
		)
		#elif($e._et == 24)
		(
			#("Bitset256=")
		)
		#elif($e._et == 25)
		(
			#("Bitset512=")
		)
		#elif($e._et == 26)
		(
			#("DateDuration=")
		)
		#elif($e._et == 27)
		(
			#("TimeDuration=")
		)
		#elif($e._et == 28)
		(
			#("DateTimeDuration=")
		)
		#elif($e._et == 29)
		(
			#("MapVariantVariant=")
		)
		#elif($e._et == 30)
		(
			#("MultimapVariantVariant=")
		)
		#elif($e._et == 31)
		(
			#("MultimapStringVariant=")
		)
		#elif($e._et == 32)
		(
			#("SetVariant=")
		)
		#elif($e._et == 33)
		(
			#("MultisetVariant=")
		)
		#elif($e._et == 34)
		(
			#("DequeVariant=")
		)
		#elif($e._et == 35)
		(
			#("ListVariant=")
		)
		#else
		(
			#("UNKNOWN!!!")
		)		
	)

}







; This section lets you define your own errors for the HRESULT display.
; You need to list the error code in unsigned decimal, followed by the message.
; Changes will take effect the next time you redisplay the variable.


[hresult]
;1234=my custom error code

















