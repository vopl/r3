#include "pch.h"
#include "networkReply.hpp"

namespace client
{
	namespace qt
	{
		//////////////////////////////////////////////////////////////////////////
		bool NetworkReply::atEnd () const
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		qint64 NetworkReply::bytesAvailable () const
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		qint64 NetworkReply::bytesToWrite () const
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		bool NetworkReply::canReadLine () const
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		void NetworkReply::close ()
		{
			assert(0);
			return;
		}

		//////////////////////////////////////////////////////////////////////////
		bool NetworkReply::isSequential () const
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		bool NetworkReply::open ( OpenMode mode )
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		qint64 NetworkReply::pos () const
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		bool NetworkReply::reset ()
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		bool NetworkReply::seek ( qint64 pos )
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		qint64 NetworkReply::size () const
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		bool NetworkReply::waitForBytesWritten ( int msecs )
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		bool NetworkReply::waitForReadyRead ( int msecs )
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		qint64 NetworkReply::readData ( char * data, qint64 maxSize )
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		qint64 NetworkReply::readLineData ( char * data, qint64 maxSize )
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		qint64 NetworkReply::writeData ( const char * data, qint64 maxSize )
		{
			assert(0);
			return 0;
		}

		//////////////////////////////////////////////////////////////////////////
		void NetworkReply::abort()
		{
			assert(0);
		}

		//////////////////////////////////////////////////////////////////////////
		void NetworkReply::setReadBufferSize ( qint64 size )
		{
			assert(0);
		}

		//////////////////////////////////////////////////////////////////////////
		void NetworkReply::ignoreSslErrors ()
		{
			assert(0);
		}

		//////////////////////////////////////////////////////////////////////////
		void NetworkReply::onReceive(
			IAgentHubPtr hub,
			const server::TEndpoint &endpoint,
			utils::VariantPtr data)
		{
			assert(0);
		}

		//////////////////////////////////////////////////////////////////////////
		NetworkReply::NetworkReply(QObject *parent, QUrl url)
		{
			utils::VariantPtr v(new utils::Variant);
			utils::Variant::MapStringVariant &m = v->as<utils::Variant::MapStringVariant>(true);
			m["cmd"] = "get";
			m["path"] = url.path().toUtf8().constData();

			send(url.host().toUtf8().constData(), v);

			emit finished();
		}

		//////////////////////////////////////////////////////////////////////////
		NetworkReply::~NetworkReply()
		{
			assert(0);
		}
	}
}
